<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Tutorial on the Elpi programming language</title>
<meta name="author" content="Enrico Tassi" />
<script type="text/javascript" defer src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.min.js?config=TeX-AMS_CHTML"></script>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.min.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.13.0+0.13.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="tutorial-on-the-elpi-programming-language">
<h1 class="title">Tutorial on the Elpi programming language</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Enrico Tassi</td></tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<!-- Elpi is an extension language that comes as a library
to be embedded into host applications such as Coq.

Elpi is a variant of ŒªProlog enriched with constraints.
ŒªProlog is a programming language designed to make it easy
to manipulate abstract syntax trees containing binders.
Elpi extends ŒªProlog with modes and constraints in order
to make it easy to manipulate abstract syntax trees
containing metavariables (also called unification variables, or
evars in the Coq jargon).

This software, "coq-elpi", is a Coq plugin embedding Elpi and
exposing to the extension language Coq specific data types (e.g. terms)
and API (e.g. to declare a new inductive type).

In order to get proper syntax highlighting using VSCode please install the
"gares.coq-elpi-lang" extension. In CoqIDE please chose "coq-elpi" in
Edit -> Preferences -> Colors. -->
<p>This little tutorial does not talk about Coq, but rather focuses on
Elpi as a programming language. It assumes no previous knowledge of
Prolog and ŒªProlog. Coq can be used as an environment for stepping trough
the tutorial one paragraph at a time. The text between <code class="highlight coq"><span class="name">lp</span><span class="operator">:{{</span></code> and <code class="highlight coq"><span class="operator">}}</span></code> is
Elpi code, while the rest are Coq directives to drive the interpreter.</p>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#logic-programming-unification-and-backtracking" id="id1">Logic programming: unification and backtracking</a></li>
<li><a class="reference internal" href="#higher-order-features" id="id2">Higher order features</a></li>
<li><a class="reference internal" href="#modes-and-constraints" id="id3">Modes and constraints</a></li>
<li><a class="reference internal" href="#functional-style" id="id4">Functional style</a></li>
<li><a class="reference internal" href="#debugging" id="id5">Debugging</a></li>
<li><a class="reference internal" href="#further-reading" id="id6">Further reading</a></li>
</ul>
</div>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">From</span> elpi <span class="kn">Require Import</span> elpi.</span></span></span></pre><div class="section" id="logic-programming-unification-and-backtracking">
<h1><a class="toc-backref" href="#id1">Logic programming: unification and backtracking</a></h1>
<p>We start by introducing the first order fragment of
ŒªProlog, i.e. the terms will not contains binders.</p>
<p>Our first program is called <code class="highlight coq"><span class="name">tutorial</span></code>.</p>
<p>We begin by declaring the (typed) signature of our terms.
Here we declare that <code class="highlight coq"><span class="name">person</span></code> is a type, and that
<code class="highlight coq"><span class="name">mallory</span></code>, <code class="highlight coq"><span class="name">bob</span></code> and <code class="highlight coq"><span class="name">alice</span></code> are terms of that type.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Program tutorial lp:{{

  kind person  type.
  type mallory, bob, alice  person.

}}.</span></span></span></pre><p>A ŒªProlog program is made of clauses that declare
when a predicate holds. Clauses are accumulated one after the
other into a program.</p>
<p>The next commands accumulates on top
of the current <code class="highlight coq"><span class="name">tutorial</span></code> program a predicate declaration for <code class="highlight coq"><span class="name">age</span></code>
and 3 clauses representing our knowledge about our terms.</p>
<p>Note that <code class="highlight coq"><span class="name">int</span></code> is the primitive data type of integers.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Accumulate lp:{{

  pred age o:person, o:int.

  age mallory <span class="mi">23</span>.
  age bob <span class="mi">23</span>.
  age alice <span class="mi">20</span>.

}}.</span></span></span></pre><p>The predicate <code class="highlight coq"><span class="name">age</span></code> has two arguments, the former is a person while
the latter is an integer. The label <code class="highlight coq"><span class="name">o</span><span class="operator">:</span></code> (standing for &quot;output&quot;)
is a mode declaration and are explained later on, for now they can be
ignored.</p>
<p>Now that we have a program we can run it!</p>
<p>The entry point of a program is called a query,
i.e. a predicate expression containing variables such as</p>
<pre class="code literal-block">
age alice A
</pre>
<p>and the execution of the program is expected to assign to <code class="highlight coq"><span class="name">A</span></code> the
age of alice.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p>Syntactic conventions:</p>
<ul class="last simple">
<li>Variables are identifiers starting with a capital letter, eg
<code class="highlight coq"><span class="name">A</span></code>, <code class="highlight coq"><span class="name">B</span></code>, <code class="highlight coq"><span class="name">FooBar</span></code>, <code class="highlight coq"><span class="name">Foo_bar</span></code>, <code class="highlight coq"><span class="name">X1</span></code></li>
<li>constants (for individuals or predicates) are identifiers
starting with a lowercase letter, eg
<code class="highlight coq"><span class="name">foo</span></code>, <code class="highlight coq"><span class="name">bar</span></code>, <code class="highlight coq"><span class="name">this_that</span></code>, <code class="highlight coq"><span class="name">camelCase</span></code>, <code class="highlight coq"><span class="name">dash</span><span class="operator">-</span><span class="name">allowed</span></code>, <code class="highlight coq"><span class="name">qmark_too</span><span class="operator">?</span></code>,
<code class="highlight coq"><span class="name">arrows</span><span class="operator">-&gt;</span><span class="name">as_well</span></code></li>
</ul>
</div>
<p>A query can be composed of many predicate expressions linked by <tt class="docutils literal">,</tt>
that stands for conjunction: we want to get an answer to all of the
predicate expressions.</p>
<p><code class="highlight coq"><span class="name">coq</span><span class="operator">.</span><span class="name">say</span></code> is a built-in predicate provided by Coq-Elpi, and API which
takes any arguments and tells Coq to print them.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk0"><span class="highlight">Elpi Query lp:{{

  age alice A, coq.say <span class="s2">&quot;The age of alice is&quot;</span> A

}}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">The age of alice <span class="kr">is</span> <span class="mi">20</span></span></blockquote><blockquote class="alectryon-message"><span class="highlight">Query assignments:</span></blockquote><blockquote class="alectryon-message"><span class="highlight">A = <span class="mi">20</span></span></blockquote></div></div></small></span></pre><p>Note that <tt class="docutils literal">&quot;strings&quot;</tt> are also a primitive data type.</p>
<p><code class="highlight coq"><span class="name">age</span></code> is said to be a relation (in contrast to a function), since it computes
both ways: we can ask Elpi which person <code class="highlight coq"><span class="name">P</span></code> is 23 years old.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk1"><span class="highlight">Elpi Query lp:{{

  age P <span class="mi">23</span>, coq.say P <span class="s2">&quot;is 23 years old&quot;</span>

}}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">mallory <span class="kr">is</span> <span class="mi">23</span> years old</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Query assignments:</span></blockquote><blockquote class="alectryon-message"><span class="highlight">P = mallory</span></blockquote></div></div></small></span></pre><p>Operationally, the query <code class="highlight coq"><span class="name">age</span> <span class="name">P</span> <span class="literal number integer">23</span></code> is unified with each
and every clause present in the program starting from the first one.</p>
<p>Unification compares two
terms structurally and eventually assigns variables.</p>
<p>For example for the first clause of the program we obtain
the following unification problem</p>
<pre class="code literal-block">
age P 23 = age mallory 23
</pre>
<p>that is simplified into smaller equations following
the structure of the terms</p>
<pre class="code literal-block">
age = age
P = mallory
23 = 23
</pre>
<p>The second can be satisfied by assigning <code class="highlight coq"><span class="name">mallory</span></code> to <code class="highlight coq"><span class="name">P</span></code>.
All equations are solved, hence unification succeeds.
Note that the <tt class="docutils literal">=</tt> sign is a regular predicate. Indeed the query
<code class="highlight coq"><span class="name">age</span> <span class="name">P</span> <span class="literal number integer">23</span></code> can be rewritten as</p>
<pre class="code literal-block">
A = 23, age P A
</pre>
<p>See also the <a class="reference external" href="https://en.wikipedia.org/wiki/Unification_(computer_science)#Syntactic_unification_of_first-order_terms">Wikipedia page on Unification</a>.</p>
<p>The first part of the query is succesful and the rest of
the query is run: the value of <code class="highlight coq"><span class="name">P</span></code> is printed as well as
the <code class="highlight coq"><span class="keyword reserved">is</span> <span class="literal number integer">23</span> <span class="name">years</span> <span class="name">old</span></code> string.</p>
<p>Let's try a query harder to solve!</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk2"><span class="highlight">Elpi Query lp:{{

  age P <span class="mi">20</span>, coq.say P <span class="s2">&quot;is 20 years old&quot;</span>

}}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">alice <span class="kr">is</span> <span class="mi">20</span> years old</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Query assignments:</span></blockquote><blockquote class="alectryon-message"><span class="highlight">P = alice</span></blockquote></div></div></small></span></pre><p>This time the unification problem for the first clause
in the program is</p>
<pre class="code literal-block">
age P 20 = age mallory 23
</pre>
<p>that is simplified into smaller equations following
the structure of the terms</p>
<pre class="code literal-block">
age = age
P = mallory
20 = 23
</pre>
<p>The second equation assigns <code class="highlight coq"><span class="name">P</span></code>, but the third one fails.</p>
<p>When failure occurs, the next clause in the program is
tried and all assignements are undone, i.e. <code class="highlight coq"><span class="name">P</span></code> is fresh again.
This operation is called backtracking.</p>
<p>The unification problem for the next clause is</p>
<pre class="code literal-block">
age P 20 = age bob 23
</pre>
<p>This one also fails.  The last one is</p>
<pre class="code literal-block">
age P 20 = age alice 20
</pre>
<p>This one works, and the assigment <code class="highlight coq"><span class="name">P</span> <span class="operator">=</span> <span class="name">alice</span></code> is kept as the result
of the first part of the query.</p>
<p>An even harder query is the following one where we ask for two distinct
individuals to have the same age.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk3"><span class="highlight">Elpi Query lp:{{

  age P A, age Q A, not(P = Q),
  coq.say P <span class="s2">&quot;and&quot;</span> Q <span class="s2">&quot;are&quot;</span> A <span class="s2">&quot;years old&quot;</span>

}}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">mallory <span class="kn">and</span> bob are <span class="mi">23</span> years old</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Query assignments:</span></blockquote><blockquote class="alectryon-message"><span class="highlight">A = <span class="mi">23</span></span></blockquote><blockquote class="alectryon-message"><span class="highlight">P = mallory</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Q = bob</span></blockquote></div></div></small></span></pre><p>This example shows that backtracking is global.  The first solution for
<code class="highlight coq"><span class="name">age</span> <span class="name">P</span> <span class="name">A</span></code> and <code class="highlight coq"><span class="name">age</span> <span class="name">Q</span> <span class="name">A</span></code> picks <code class="highlight coq"><span class="name">P</span></code> and <code class="highlight coq"><span class="name">Q</span></code> to be the same individual <code class="highlight coq"><span class="name">mallory</span></code>,
but then <code class="highlight coq"><span class="name">not</span><span class="operator">(</span><span class="name">P</span> <span class="operator">=</span> <span class="name">Q</span><span class="operator">)</span></code> fails and forces the last choice that was made to be
reconsidered, so <code class="highlight coq"><span class="name">Q</span></code> becomes <code class="highlight coq"><span class="name">bob</span></code>.</p>
<p>Look at the output of the following instrumented code:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk4"><span class="highlight">Elpi Query lp:{{

   age P A, age Q A, coq.say <span class="s2">&quot;I picked&quot;</span> P <span class="s2">&quot;and&quot;</span> Q,
   not(P = Q),
   coq.say <span class="s2">&quot;the last choice worked!&quot;</span>,
   coq.say P <span class="s2">&quot;and&quot;</span> Q <span class="s2">&quot;are&quot;</span> A <span class="s2">&quot;years old&quot;</span>

}}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">I picked mallory <span class="kn">and</span> mallory</span></blockquote><blockquote class="alectryon-message"><span class="highlight">I picked mallory <span class="kn">and</span> bob</span></blockquote><blockquote class="alectryon-message"><span class="highlight">the <span class="nb">last</span> choice worked!</span></blockquote><blockquote class="alectryon-message"><span class="highlight">mallory <span class="kn">and</span> bob are <span class="mi">23</span> years old</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Query assignments:</span></blockquote><blockquote class="alectryon-message"><span class="highlight">A = <span class="mi">23</span></span></blockquote><blockquote class="alectryon-message"><span class="highlight">P = mallory</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Q = bob</span></blockquote></div></div></small></span></pre><p>The clauses we have seen so far are facts: they always hold.
In general clauses can have premises, that is conditions necessary in
order to make the predicate hold.</p>
<p>Here we add to our program a clase that defines what <code class="highlight coq"><span class="name">older</span> <span class="name">P</span> <span class="name">Q</span></code> means
in terms of the <code class="highlight coq"><span class="name">age</span></code> of <code class="highlight coq"><span class="name">P</span></code> and <code class="highlight coq"><span class="name">Q</span></code>. Note that <code class="highlight coq"><span class="operator">&gt;</span></code> is a built-in predicate
on numbers with the expected meaning.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Accumulate lp:{{

  pred older o:person, o:person.
  older P Q :- age P N, age Q M, N &gt; M.

}}.</span></span></span></pre><p>Let's run a query using older</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk5"><span class="highlight">Elpi Query lp:{{

  older bob X,
  coq.say <span class="s2">&quot;bob is older than&quot;</span> X

}}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">bob <span class="kr">is</span> older than alice</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Query assignments:</span></blockquote><blockquote class="alectryon-message"><span class="highlight">X = alice</span></blockquote></div></div></small></span></pre><p>The query <code class="highlight coq"><span class="name">older</span> <span class="name">bob</span> <span class="name">X</span></code> is unified with the head of
the program clause <code class="highlight coq"><span class="name">older</span> <span class="name">P</span> <span class="name">Q</span></code> (what is to the left of <code class="highlight coq"><span class="operator">:-</span></code>),
assigning <code class="highlight coq"><span class="name">P</span> <span class="operator">=</span> <span class="name">bob</span></code> and <code class="highlight coq"><span class="name">X</span> <span class="operator">=</span> <span class="name">Q</span></code>.  Then new queries are run:</p>
<pre class="code literal-block">
age bob N
age Q M
N &gt; M
</pre>
<p>The former assigns <code class="highlight coq"><span class="name">N</span> <span class="operator">=</span> <span class="literal number integer">23</span></code>, the second one first
sets <code class="highlight coq"><span class="name">Q</span> <span class="operator">=</span> <span class="name">mallory</span></code> and <code class="highlight coq"><span class="name">M</span> <span class="operator">=</span> <span class="literal number integer">23</span></code>.  This makes the last
query to fail, since <code class="highlight coq"><span class="literal number integer">23</span> <span class="operator">&gt;</span> <span class="literal number integer">23</span></code> is false.  Hence the
second query is run again and again until <code class="highlight coq"><span class="name">Q</span></code> is
set to <code class="highlight coq"><span class="name">alice</span></code> and <code class="highlight coq"><span class="name">M</span></code> to <code class="highlight coq"><span class="literal number integer">20</span></code>.</p>
<p>Variables in the query are said to be existentially
quantified because ŒªProlog will try to find one
possible value for them.</p>
<p>Conversely, the variables used in clauses are
universally quantified in the front of the clause.
This means that the same program clause can be used
multiple times, and each time the variables are fresh.</p>
<p>Here the variable <code class="highlight coq"><span class="name">P</span></code> in <code class="highlight coq"><span class="name">older</span> <span class="name">P</span> <span class="name">Q</span> <span class="operator">:-</span> <span class="operator">...</span></code> once takes
<code class="highlight coq"><span class="name">bob</span></code> and another time takes <code class="highlight coq"><span class="name">mallory</span></code>.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk6"><span class="highlight">Elpi Query lp:{{

  older bob X, older mallory X,
  coq.say <span class="s2">&quot;bob and mallory are older than&quot;</span> X

}}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">bob <span class="kn">and</span> mallory are older than alice</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Query assignments:</span></blockquote><blockquote class="alectryon-message"><span class="highlight">X = alice</span></blockquote></div></div></small></span></pre></div>
<div class="section" id="higher-order-features">
<h1><a class="toc-backref" href="#id2">Higher order features</a></h1>
<p>So far the syntax of terms is based on constants
(eg <code class="highlight coq"><span class="name">age</span></code> or <code class="highlight coq"><span class="name">mallory</span></code>) and variables (eg <code class="highlight coq"><span class="name">X</span></code>).</p>
<p>ŒªProlog adds to constants another term constructor:
Œª-abstraction (written <code class="highlight coq"><span class="name">x</span><span class="operator">\</span> <span class="operator">...</span></code>). The variable name
before the <tt class="docutils literal">\</tt> can be capital as well: given that it is
explicitly bound Elpi needs not to guess if it is a global
symbol or a clause variable (that required the convention of
using capitals for variables).</p>
<p>Functions built using Œª-abstraction can be applied
to arguments and honor the usual Œ≤-reduction rule
(the argument is substituted for the bound variable).</p>
<p>In the following example <code class="highlight coq"><span class="name">F</span> <span class="literal number integer">23</span></code> reads, once
the Œ≤-reduction is performed, <code class="highlight coq"><span class="name">age</span> <span class="name">alice</span> <span class="literal number integer">23</span></code>.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk7"><span class="highlight">Elpi Query lp:{{

  F = (x\ age alice x),
  coq.say <span class="s2">&quot;F =&quot;</span> F,
  coq.say <span class="s2">&quot;F 20 =&quot;</span> (F <span class="mi">20</span>),
  coq.say <span class="s2">&quot;F 23 =&quot;</span> (F <span class="mi">23</span>)

}}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">F = c0 \ age alice c0</span></blockquote><blockquote class="alectryon-message"><span class="highlight">F <span class="mi">20</span> = age alice <span class="mi">20</span></span></blockquote><blockquote class="alectryon-message"><span class="highlight">F <span class="mi">23</span> = age alice <span class="mi">23</span></span></blockquote><blockquote class="alectryon-message"><span class="highlight">Query assignments:</span></blockquote><blockquote class="alectryon-message"><span class="highlight">  F = c0 \
age alice c0</span></blockquote></div></div></small></span></pre><p>Let's now write the &quot;hello world&quot; of ŒªProlog: an
interpreter and type checker for the simply
typed lambda calculus. We call this program <code class="highlight coq"><span class="name">stlc</span></code>.</p>
<p>We start by declaring that <code class="highlight coq"><span class="name">term</span></code> is a type and
that <code class="highlight coq"><span class="name">app</span></code> and <code class="highlight coq"><span class="keyword reserved">fun</span></code> are constructors of that type.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Program stlc lp:{{

  kind  term  type.

  type  app   term -&gt; term -&gt; term.
  type  <span class="kr">fun</span>   (<span class="nv">term</span> -&gt; term) -&gt; term.

}}.</span></span></span></pre><p>The constructor <code class="highlight coq"><span class="name">app</span></code> takes two terms
while <code class="highlight coq"><span class="keyword reserved">fun</span></code> only one (of functional type).</p>
<p>Note that</p>
<ul class="simple">
<li>there is no constructor for variables, we will
use the notion of bound variable of ŒªProlog in order
to represent variables</li>
<li><code class="highlight coq"><span class="keyword reserved">fun</span></code> takes a function as subterm, i.e. something
we can build using the Œª-abstraction <code class="highlight coq"><span class="name">x</span><span class="operator">\</span> <span class="operator">...</span></code></li>
</ul>
<p>As a consequence, the identity function is written</p>
<pre class="code literal-block">
fun (x\ x)
</pre>
<p>while the <code class="highlight coq"><span class="keyword pseudo">first</span></code> function is written</p>
<pre class="code literal-block">
fun (x\ fun (y\ x))
</pre>
<p>Another consequence of this approach is that there is no
such thing as a free variable. One can have (global) constants,
but variables are only available under the Œª-abstraction of the
programming language, that gives them a well defined scope and
substitution operation (Œ≤-reduction).</p>
<p>This approach is called <a class="reference external" href="https://en.wikipedia.org/wiki/Higher-order_abstract_syntax">HOAS</a>.</p>
<p>We can now implement weak head reduction, that is we stop reducing
when the term is a <code class="highlight coq"><span class="keyword reserved">fun</span></code> or a global constant (potentially applied).</p>
<p>If the term is <code class="highlight coq"><span class="name">app</span> <span class="operator">(</span><span class="keyword reserved">fun</span> <span class="name variable">F</span><span class="operator">)</span> <span class="name">A</span></code> then we compute the reduct <code class="highlight coq"><span class="name">F</span> <span class="name">A</span></code>.
Note that <code class="highlight coq"><span class="name">F</span></code> is a ŒªProlog function, so passing an argument to it
implements the substitution of the actual argument for the bound variable.</p>
<p>We first give a type and a mode for our predicate <code class="highlight coq"><span class="name">whd</span></code>. It reads
&quot;whd takes a term in input and gives a term in output&quot;. We will
explain what input means precisely later, for now just think about it
as a comment.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Accumulate lp:{{

  pred whd i:term, o:term.

  % when the head <span class="s2">&quot;Hd&quot;</span> of an <span class="s2">&quot;app&quot;</span> (lication) <span class="kr">is</span> a
  % <span class="s2">&quot;fun&quot;</span> we substitute <span class="kn">and</span> continue
  whd (app Hd Arg) Reduct :- whd Hd (<span class="kr">fun</span> <span class="nv">F</span>), !,
    whd (F Arg) Reduct.

  % otherwise a term X <span class="kr">is</span> already <span class="kr">in</span> normal form.
  whd X Reduct :- Reduct = X.

}}.</span></span></span></pre><p>Recall that, due to backtracking, all clauses are potentially used.</p>
<p>Here, whenever the first premise of the first clause applies,
we want the second clause to be skipped, since we found a redex (that is not
in weak head normal form).</p>
<p>The premises of a clause are run in order, and the <code class="highlight coq"><span class="operator">!</span></code> operator discards all
alternative clauses following the current one. Said otherwise it commits to
the currently chosen clause for the current query (but leaves
all clauses available for subsequent queries).</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk8"><span class="highlight">Elpi Query lp:{{

  I = (<span class="kr">fun</span> <span class="nv">x</span>\x),
  whd I T, coq.say <span class="s2">&quot;Œªx.x ~&gt;&quot;</span> T,
  whd (app I I) T1, coq.say <span class="s2">&quot;(Œªx.x) (Œªx.x) ~&gt;&quot;</span> T1

}}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight"><span class="kr">Œª</span><span class="nv">x</span>.x ~&gt; <span class="kr">fun</span> <span class="nv">c0</span> \ c0</span></blockquote><blockquote class="alectryon-message"><span class="highlight">(<span class="kr">Œª</span><span class="nv">x</span>.x) (<span class="kr">Œª</span><span class="nv">x</span>.x) ~&gt; <span class="kr">fun</span> <span class="nv">c0</span> \ c0</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Query assignments:</span></blockquote><blockquote class="alectryon-message"><span class="highlight">I = <span class="kr">fun</span> <span class="nv">c0</span> \ c0</span></blockquote><blockquote class="alectryon-message"><span class="highlight">T = <span class="kr">fun</span> <span class="nv">c0</span> \ c0</span></blockquote><blockquote class="alectryon-message"><span class="highlight">T1 = <span class="kr">fun</span> <span class="nv">c0</span> \ c0</span></blockquote></div></div></small></span></pre><p>Another little test using global constants:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Accumulate lp:{{

  type foo, bar term.

}}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk9"><span class="highlight">Elpi Query lp:{{

  Fst = <span class="kr">fun</span> (<span class="nv">x</span>\ <span class="kr">fun</span> <span class="nv">y</span>\ x),
  T = app (app Fst foo) bar,
  whd T T1, coq.say <span class="s2">&quot;(Fst foo bar) ~&gt;&quot;</span> T1,
  S = app foo bar,
  whd S S1, coq.say <span class="s2">&quot;(foo bar) ~&gt;&quot;</span> S1

}}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">(Fst foo bar) ~&gt; foo</span></blockquote><blockquote class="alectryon-message"><span class="highlight">(foo bar) ~&gt; app foo bar</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Query assignments:</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Fst = <span class="kr">fun</span> <span class="nv">c0</span> \ <span class="kr">fun</span> <span class="nv">c1</span> \ c0</span></blockquote><blockquote class="alectryon-message"><span class="highlight">S = app foo bar</span></blockquote><blockquote class="alectryon-message"><span class="highlight">S1 = app foo bar</span></blockquote><blockquote class="alectryon-message"><span class="highlight">T = app (app (<span class="kr">fun</span> <span class="nv">c0</span> \ <span class="kr">fun</span> <span class="nv">c1</span> \ c0) foo) bar</span></blockquote><blockquote class="alectryon-message"><span class="highlight">T1 = foo</span></blockquote></div></div></small></span></pre><p>A last test with a lambda term that has no weak head normal form</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Bound Steps <span class="mi">1000</span>. <span class="c">(* Let&#39;s be cautious *)</span></span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chka"><span class="highlight"><span class="kn">Fail</span> Elpi Query lp:{{

  Delta = <span class="kr">fun</span> (<span class="nv">x</span>\ app x x),
  Omega = app Delta Delta,
  whd Omega Hummm, coq.say <span class="s2">&quot;not going to happen&quot;</span>

}}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">The command has indeed failed <span class="kr">with</span> message:
elpi run out of steps (<span class="mi">1000</span>)</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Bound Steps <span class="mi">0</span>.</span></span></span></pre><p>Remark we have used the binders of ŒªProlog to implement substitution.
This feature is complemented by the <code class="highlight coq"><span class="name">pi</span></code> operator and the <code class="highlight coq"><span class="operator">=&gt;</span></code> connective
in order to be able to recurse under a binder.</p>
<p>A good showcase for these features is to implement a type checker
for the simply typed lambda calculus.
See also <a class="reference external" href="https://en.wikipedia.org/wiki/Simply_typed_lambda_calculus">the Wikipedia page on the simply typed lambda calculus</a>.</p>
<p>We start by defining the data type of simple types.
We then declare a new predicate <code class="highlight coq"><span class="name">of</span></code> (for type of) and finally
we provide two clauses, one for each term constructor.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Accumulate lp:{{

  kind  ty   type.           % the data <span class="kp">type of</span> types
  type  arr  ty -&gt; ty -&gt; ty. % our type <span class="nb">constructor</span>

  pred of i:term, o:ty. % the type checking algorithm

  % <span class="kr">for</span> the app node we ensure the head <span class="kr">is</span> a function <span class="kn">from</span>
  % A to B, <span class="kn">and</span> that the argument <span class="kr">is</span> of type A
  of (app Hd Arg) B :-
    of Hd (arr A B), of Arg A.

  % <span class="kr">for</span> lambda, instead of <span class="nb">using</span> a <span class="kp">context</span> (a list) of bound
  % variables we use the pi <span class="kn">and</span> =&gt; primitives, explained below
  of (<span class="kr">fun</span> <span class="nv">F</span>) (arr A B) :-
    pi x\ of x A =&gt; of (F x) B.

}}.</span></span></span></pre><p><code class="highlight coq"><span class="name">pi</span> <span class="operator">&lt;</span><span class="name">name</span><span class="operator">&gt;\</span> <span class="operator">&lt;</span><span class="name">code</span><span class="operator">&gt;</span></code> is a reserved syntax, as well as
<code class="highlight coq"><span class="operator">&lt;</span><span class="name">code</span><span class="operator">&gt;</span> <span class="operator">=&gt;</span> <span class="operator">&lt;</span><span class="name">code</span><span class="operator">&gt;</span></code>.</p>
<p>Operationally <code class="highlight coq"><span class="name">pi</span> <span class="name">x</span><span class="operator">\</span> <span class="name">code</span></code> introduces a fresh
constant x and then runs <code class="highlight coq"><span class="name">code</span></code>.
Operationally <code class="highlight coq"><span class="name">clause</span> <span class="operator">=&gt;</span> <span class="name">code</span></code> adds <code class="highlight coq"><span class="name">clause</span></code> to
the program and runs <code class="highlight coq"><span class="name">code</span></code>.  Such extra clause is
said to be hypothetical.</p>
<p>Both <code class="highlight coq"><span class="name">x</span></code> and <code class="highlight coq"><span class="name">clause</span></code> are removed once <code class="highlight coq"><span class="name">code</span></code> terminates.</p>
<p>Note that the hypothetical clause is <code class="highlight coq"><span class="name">of</span> <span class="name">x</span> <span class="name">A</span></code> for
a fixed <code class="highlight coq"><span class="name">A</span></code> and a fresh constant <code class="highlight coq"><span class="name">x</span></code>. <code class="highlight coq"><span class="name">A</span></code> is fixed but not assigned yet, meaning
that <code class="highlight coq"><span class="name">x</span></code> has a type, but only one which is yet unknown.</p>
<p>Note that hypothetical clauses are added at the top of the
program, that is they take precedence over static clauses.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chkb"><span class="highlight">Elpi Query lp:{{

  of (<span class="kr">fun</span> (<span class="nv">x</span>\ <span class="kr">fun</span> <span class="nv">y</span>\ x)) Ty, coq.say <span class="s2">&quot;The type of Fst is:&quot;</span> Ty

}}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">The <span class="kp">type of</span> Fst <span class="kr">is</span>: arr X0 (arr X1 X0)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Query assignments:</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Ty = arr X0 (arr X1 X0)</span></blockquote></div></div></small></span></pre><p>Let's run step by step this example.</p>
<p>The clause for <code class="highlight coq"><span class="keyword reserved">fun</span></code> is used:
* <code class="highlight coq"><span class="name">Ty</span></code> is assigned <code class="highlight coq"><span class="name">arrow</span> <span class="name">A1</span> <span class="name">B1</span></code>
* a fresh constant <code class="highlight coq"><span class="name">c1</span></code> is created by the <code class="highlight coq"><span class="name">pi</span></code> construct
* <code class="highlight coq"><span class="name">of</span> <span class="name">c1</span> <span class="name">A1</span></code> is added to the program by the <code class="highlight coq"><span class="operator">=&gt;</span></code> construct,
* the new query <code class="highlight coq"><span class="name">of</span> <span class="operator">(</span><span class="keyword reserved">fun</span> <span class="name variable">y</span><span class="operator">\</span> <span class="name">c1</span><span class="operator">)</span> <span class="name">B1</span></code> is run.</p>
<p>Again, the clause for <code class="highlight coq"><span class="keyword reserved">fun</span></code> is used (since its variables are
universally quantified, we use fresh <code class="highlight coq"><span class="name">A2</span></code>, <code class="highlight coq"><span class="name">B2</span></code>... this time):
* <code class="highlight coq"><span class="name">B1</span></code> is assigned <code class="highlight coq"><span class="name">arrow</span> <span class="name">A2</span> <span class="name">B2</span></code>
* a fresh <code class="highlight coq"><span class="name">c2</span></code> is created by the <code class="highlight coq"><span class="name">pi</span></code> construct
* <code class="highlight coq"><span class="name">of</span> <span class="name">c2</span> <span class="name">A2</span></code> is added to the program by the <code class="highlight coq"><span class="operator">=&gt;</span></code> construct,
* the new query <code class="highlight coq"><span class="name">of</span> <span class="name">c1</span> <span class="name">B2</span></code> is run.</p>
<p>The (hypotetical) clause <code class="highlight coq"><span class="name">of</span> <span class="name">c1</span> <span class="name">A1</span></code> is used:
* <code class="highlight coq"><span class="name">B2</span></code> gets assigned to <code class="highlight coq"><span class="name">A1</span></code></p>
<p>The value of <code class="highlight coq"><span class="name">Ty</span></code> is hence <code class="highlight coq"><span class="name">arr</span> <span class="name">A1</span> <span class="operator">(</span><span class="name">arr</span> <span class="name">A2</span> <span class="name">A1</span><span class="operator">)</span></code>, a good type
for the fst function (the first argument and the output
have the same type <code class="highlight coq"><span class="name">A1</span></code>).</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chkc"><span class="highlight">Elpi Query lp:{{

  Delta = <span class="kr">fun</span> (<span class="nv">x</span>\ app x x),
  (of Delta Ty ; coq.say <span class="s2">&quot;Error:&quot;</span> Delta <span class="s2">&quot;has no type&quot;</span>)

}}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">Error: <span class="kr">fun</span> <span class="nv">c0</span> \ app c0 c0 has no type</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Query assignments:</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Delta = <span class="kr">fun</span> <span class="nv">c0</span> \ app c0 c0</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Ty = X0</span></blockquote></div></div></small></span></pre><p>The <code class="highlight coq"><span class="operator">;</span></code> infix operator stands for disjunction: if we see the message
then <code class="highlight coq"><span class="name">of</span></code> failed.</p>
<p>The term <code class="highlight coq"><span class="keyword reserved">fun</span> <span class="operator">(</span><span class="name variable">x</span><span class="operator">\</span> <span class="name">app</span> <span class="name">x</span> <span class="name">x</span><span class="operator">)</span></code> is not well typed.</p>
<p>First, the clause for fun is used:</p>
<ul class="simple">
<li><code class="highlight coq"><span class="name">Ty</span></code> is assigned <code class="highlight coq"><span class="name">arrow</span> <span class="name">A1</span> <span class="name">B1</span></code></li>
<li>a fresh <code class="highlight coq"><span class="name">c1</span></code> is created by the <code class="highlight coq"><span class="name">pi</span></code> construct</li>
<li><code class="highlight coq"><span class="name">of</span> <span class="name">c1</span> <span class="name">A1</span></code> is added to the program by the <code class="highlight coq"><span class="operator">=&gt;</span></code> construct,
the new query <code class="highlight coq"><span class="name">of</span> <span class="operator">(</span><span class="name">app</span> <span class="name">c1</span> <span class="name">c1</span><span class="operator">)</span> <span class="name">B1</span></code> is run.</li>
</ul>
<p>Then it's the turn of typing the application:</p>
<ul class="simple">
<li>the query <code class="highlight coq"><span class="name">of</span> <span class="name">c1</span> <span class="operator">(</span><span class="name">arr</span> <span class="name">A2</span> <span class="name">B2</span><span class="operator">)</span></code> assignes to <code class="highlight coq"><span class="name">A1</span></code> the
value <code class="highlight coq"><span class="name">arr</span> <span class="name">A2</span> <span class="name">B2</span></code>.  This means that the
hypothetical clause is now <code class="highlight coq"><span class="name">of</span> <span class="name">c1</span> <span class="operator">(</span><span class="name">arr</span> <span class="name">A2</span> <span class="name">B2</span><span class="operator">)</span></code>.</li>
<li>the query <code class="highlight coq"><span class="name">of</span> <span class="name">c1</span> <span class="name">A2</span></code> fails because
<code class="highlight coq"><span class="name">A2</span> <span class="operator">=</span> <span class="operator">(</span><span class="name">arr</span> <span class="name">A2</span> <span class="name">B2</span><span class="operator">)</span></code> has no solution</li>
</ul>
<p>The semantics of a ŒªProlog program is given by interpreting
it in terms of logical formulas and proof search.</p>
<p>A clause</p>
<pre class="code literal-block">
p A B :- q A C, r C B.
</pre>
<p>has to be understood as a formula</p>
<div class="math">
\begin{equation*}
\forall A~B~C, (\mathrm{q}~A~C \wedge  \mathrm{r}~C~B) \rightarrow  \mathrm{p}~A~B
\end{equation*}
</div>
<p>A query is a goal that is proved by backchaining
clauses.  For example <code class="highlight coq"><span class="name">p</span> <span class="literal number integer">3</span> <span class="name">X</span></code>
is solved by unifying it with the conclusion of
the formula above (that sets <code class="highlight coq"><span class="name">A</span></code> to <code class="highlight coq"><span class="literal number integer">3</span></code>) and
generating two new queries, <code class="highlight coq"><span class="name">q</span> <span class="literal number integer">3</span> <span class="name">C</span></code> and
<code class="highlight coq"><span class="name">r</span> <span class="name">C</span> <span class="name">B</span></code>. Note that <code class="highlight coq"><span class="name">C</span></code> is an argument to both
<code class="highlight coq"><span class="name">q</span></code> and <code class="highlight coq"><span class="name">r</span></code> and acts as a link: if solving <code class="highlight coq"><span class="name">q</span></code>
fixes <code class="highlight coq"><span class="name">C</span></code> then the query for <code class="highlight coq"><span class="name">r</span></code> sees that.
Similarly for <code class="highlight coq"><span class="name">B</span></code>, that is identified with <code class="highlight coq"><span class="name">X</span></code>,
and is hence a link from the solution of <code class="highlight coq"><span class="name">r</span></code> to
the solution of <code class="highlight coq"><span class="name">p</span></code>.</p>
<p>A clause like</p>
<pre class="code literal-block">
of (fun F) (arr A B) :-
  pi x\ of x A =&gt; of (F x) B.
</pre>
<p>reads, as a logical formula:</p>
<div class="math">
\begin{equation*}
\forall F~A~B, (\forall x, \mathrm{of}~x~A \rightarrow  \mathrm{of}~(F~x)~B) \rightarrow  \mathrm{of}~(\mathrm{fun}~F)~(\mathrm{arr}~A~B)
\end{equation*}
</div>
<p>or using the inference rule notation typically used for type systems</p>
<div class="math">
\begin{equation*}
\frac{\Gamma, \mathrm{of}~x~A \vdash \mathrm{of}~(F~x)~B  \quad   x~\mathrm{fresh}}{\Gamma \vdash \mathrm{of}~(\mathrm{fun}~F)~(\mathrm{arr}~A~B)}
\end{equation*}
</div>
<p>Hence, <code class="highlight coq"><span class="name">x</span></code> and <code class="highlight coq"><span class="name">of</span> <span class="name">x</span> <span class="name">A</span></code> are available only
temporarily to prove  <code class="highlight coq"><span class="name">of</span> <span class="operator">(</span><span class="name">F</span> <span class="name">x</span><span class="operator">)</span> <span class="name">B</span></code> and this is
also why <code class="highlight coq"><span class="name">A</span></code> cannot change during this sub proof (<code class="highlight coq"><span class="name">A</span></code> is
quantified once and forall outside).</p>
<p>Each program execution is a proof of the query
and is made of the program clauses seen as axioms.</p>
</div>
<div class="section" id="modes-and-constraints">
<h1><a class="toc-backref" href="#id3">Modes and constraints</a></h1>
<p>Elpi extends ŒªProlog with syntactic constraints
and rules to manipulate the set of constraints.</p>
<p>Syntactic constraints are goals suspended on
a variable and are resumed as soon as such a variable
gets instantiated.</p>
<p>A companion facility is the declaration of modes.
The argument of a predicate can be marked as input
to avoid it being instantiated when unifying the
the goal with the head of a clause.</p>
<p>A simple example: Peano's addition</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Program peano lp:{{

kind nat type.
type z nat.
type s nat -&gt; nat.

pred add o:nat, o:nat, o:nat.

add (s X) Y (s Z) :- add X Y Z.
add z X X.

}}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chkd"><span class="highlight">Elpi Query lp:{{

  add (s (s z)) (s z) R, coq.say <span class="s2">&quot;2 + 1 =&quot;</span> R

}}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight"><span class="mi">2</span> + <span class="mi">1</span> = s (s (s z))</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Query assignments:</span></blockquote><blockquote class="alectryon-message"><span class="highlight">R = s (s (s z))</span></blockquote></div></div></small></span></pre><p>Unfortunately the relation does not work well
when the first argument is a variable.  Depending on the
order of the clauses for <code class="highlight coq"><span class="name">add</span></code> Elpi can either diverge or pick
<code class="highlight coq"><span class="name">z</span></code> as a value for <code class="highlight coq"><span class="name">X</span></code> (that may not be what one wants)</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Bound Steps <span class="mi">100</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chke"><span class="highlight"><span class="kn">Fail</span> Elpi Query lp:{{ add X (s z) Y }}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">The command has indeed failed <span class="kr">with</span> message:
elpi run out of steps (<span class="mi">100</span>)</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Bound Steps <span class="mi">0</span>.</span></span></span></pre><p>Indeed the first clause for add can be applied forever.
If one exchanges the two clauses in the program, then Elpi
terminates picking <code class="highlight coq"><span class="name">z</span></code> for <code class="highlight coq"><span class="name">X</span></code>.</p>
<p>We can use the mode directive in order to
<em>match</em> arguments marked as i against the patterns
in the head of clauses, rather than unifying them.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Program peano2 lp:{{

kind nat type.
type z nat.
type s nat -&gt; nat.

pred sum i:nat, i:nat, o:nat.

sum (s X) Y (s Z) :- sum X Y Z.
sum z X X.

}}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chkf"><span class="highlight"><span class="kn">Fail</span> Elpi Query lp:{{ sum X (s z) Y }}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">The command has indeed failed <span class="kr">with</span> message:
The elpi command peano2 failed without giving a
specific error message. Please report this
inconvenience to the authors of the program.</span></blockquote></div></div></small></span></pre><p>The query fails because no clause first argument matches <code class="highlight coq"><span class="name">X</span></code>.</p>
<p>Instead of failing we can suspend goals and turn them into
syntactic constraints</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Accumulate lp:{{

sum X Y Z :-
  % this clause always applies, we double check X <span class="kr">is</span> a variable
  var X,
  % <span class="kr">then</span> we declare the constraint <span class="kn">and</span> trigger its resumption of the
  % assignment of X
  declare_constraint (sum X Y Z) [X].

}}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk10"><span class="highlight">Elpi Query lp:{{ sum X (s z) Z }}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">Query assignments:</span></blockquote><blockquote class="alectryon-message"><span class="highlight">X = X0</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Z = X1</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Syntactic constraints:
 sum X0 (s z) X1  /* suspended on X0 */</span></blockquote></div></div></small></span></pre><p>Syntactic constraints are resumed when the variable
they are suspended on is assigned</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk11"><span class="highlight">Elpi Query lp:{{

  sum X (s z) Z, X = z,
  coq.say <span class="s2">&quot;The result is:&quot;</span> Z,
  print_constraints % to be sure, prints nothing

}}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">The result <span class="kr">is</span>: s z</span></blockquote><blockquote class="alectryon-message"><span class="highlight"></span></blockquote><blockquote class="alectryon-message"><span class="highlight">Query assignments:</span></blockquote><blockquote class="alectryon-message"><span class="highlight">X = z</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Z = s z</span></blockquote></div></div></small></span></pre><p>A couple more examples:
* resumption can cause failure
* recall that <code class="highlight coq"><span class="operator">;</span></code> stands for disjunction</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk12"><span class="highlight"><span class="kn">Fail</span> Elpi Query lp:{{ sum X (s z) (s (s z)), X = z }}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">The command has indeed failed <span class="kr">with</span> message:
The elpi command peano2 failed without giving a
specific error message. Please report this
inconvenience to the authors of the program.</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk13"><span class="highlight">Elpi Query lp:{{ sum X (s z) (s (s z)), (X = z ; X = s z) }}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">Query assignments:</span></blockquote><blockquote class="alectryon-message"><span class="highlight">X = s z</span></blockquote></div></div></small></span></pre><p>Remark how computation suspends, then makes progess,
then suspends again...</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk14"><span class="highlight">Elpi Query lp:{{

   sum X (s z) Y,
   print_constraints, coq.say <span class="s2">&quot;Currently Y =&quot;</span> Y,
   X = s Z,
   print_constraints, coq.say <span class="s2">&quot;Currently Y =&quot;</span> Y,
   Z = z,
   coq.say <span class="s2">&quot;Finally Y =&quot;</span> Y

}}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">sum X0 (s z) X1  /* suspended on X0 */</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Currently Y = X1</span></blockquote><blockquote class="alectryon-message"><span class="highlight">sum X2 (s z) X3  /* suspended on X2 */</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Currently Y = s X3</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Finally Y = s (s z)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Query assignments:</span></blockquote><blockquote class="alectryon-message"><span class="highlight">X = s z</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Y = s (s z)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Z = z</span></blockquote></div></div></small></span></pre><p>Sometimes the set of syntactic constraints becomes unsatisfiable
and we would like to be able to fail early.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Accumulate lp:{{

pred even i:nat.
pred odd  i:nat.

even z.
even (s X) :- odd X.
odd (s X) :- even X.

odd X :- var X, declare_constraint (odd X) [X].
even X :- var X, declare_constraint (even X) [X].

}}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk15"><span class="highlight">Elpi Query lp:{{ even (s X), odd (s X) }}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">Query assignments:</span></blockquote><blockquote class="alectryon-message"><span class="highlight">X = X0</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Syntactic constraints:
 even X0  /* suspended on X0 */ odd X0  /* suspended on X0 */</span></blockquote></div></div></small></span></pre><p>A constraint (handling) rule can see the set of syntactic constraints
as a whole, remove constraints and/or create new goals</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Accumulate lp:{{

constraint even odd {
  % <span class="kr">if</span> two distinct, conflicting, constraints about the same X
  % are part of the store
  rule (even X) (odd X) &lt;=&gt;
   % generate the following goal
   (coq.say X <span class="s2">&quot;can&#39;t be even and odd at the same time&quot;</span>, <span class="kp">fail</span>).
}

}}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk16"><span class="highlight"><span class="kn">Fail</span> Elpi Query lp:{{ even (s X), odd (s X) }}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">X0 can&#39;t be even <span class="kn">and</span> odd <span class="nb">at</span> the same <span class="kp">time</span></span></blockquote><blockquote class="alectryon-message"><span class="highlight">The command has indeed failed <span class="kr">with</span> message:
The elpi command peano2 failed without giving a
specific error message. Please report this
inconvenience to the authors of the program.</span></blockquote></div></div></small></span></pre><p>See also the Wikipedia page on <a class="reference external" href="https://en.wikipedia.org/wiki/Constraint_Handling_Rules">Constraint Handling Rules</a>
for an introduction to the sub language to manipualte constraints.</p>
</div>
<div class="section" id="functional-style">
<h1><a class="toc-backref" href="#id4">Functional style</a></h1>
<p>Elpi is a relational language, not a functional one. Still some features
typical of functional programming are available, with some caveats.</p>
<p>First, functions about built-in data types are available via the infix <code class="highlight coq"><span class="keyword reserved">is</span></code>
predicate</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk17"><span class="highlight">Elpi Query lp:{{  X <span class="kr">is</span> <span class="mi">3</span> + <span class="mi">2</span>, Y <span class="kr">is</span> <span class="s2">&quot;result &quot;</span> ^ <span class="s2">&quot;=&quot;</span>, coq.say Y X }}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">result = <span class="mi">5</span></span></blockquote><blockquote class="alectryon-message"><span class="highlight">Query assignments:</span></blockquote><blockquote class="alectryon-message"><span class="highlight">X = <span class="mi">5</span></span></blockquote><blockquote class="alectryon-message"><span class="highlight">Y = result =</span></blockquote></div></div></small></span></pre><p>Chaining &quot;relations&quot; can be painful, especially when
they look like functions. Here we use <code class="highlight coq"><span class="name">std</span><span class="operator">.</span><span class="name">append</span></code>
and <code class="highlight coq"><span class="name">std</span><span class="operator">.</span><span class="name">rev</span></code> as examples.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Program function lp:{{

% Note that variables (capital <span class="kr">let</span><span class="nv">ters</span>) can be used <span class="kr">in</span>
% types <span class="kr">in</span> order to describe ML-like polymorphism.
pred make-palindrome i:list A, o:list A.

make-palindrome L Result :-
  std.rev L TMP,
  std.append L TMP Result.

pred make-palindrome2 i:list A, o:list A.

make-palindrome2 L Result :-
  std.append L {std.rev L} Result.

}}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk18"><span class="highlight">Elpi Query lp:{{

  % Note that list <span class="kr">is</span> a primitive data type <span class="kr">with</span> syntax
  % - [] <span class="kr">for</span> nil
  % - [Hd | Tail] <span class="kr">for</span> cons
  % - [ E1, E2 | Tail ] <span class="kr">for</span> iterated cons, <span class="kn">where</span>
  %     | Tail can be omitted <span class="kr">if</span> the list <span class="kr">is</span> nil terminated
  make-palindrome [<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>] A,
  make-palindrome2 [<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>] B,
  coq.say A <span class="s2">&quot;=&quot;</span> B

}}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">[<span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span>, <span class="mi">3</span>, <span class="mi">2</span>, <span class="mi">1</span>] = [<span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span>, <span class="mi">3</span>, <span class="mi">2</span>, <span class="mi">1</span>]</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Query assignments:</span></blockquote><blockquote class="alectryon-message"><span class="highlight">A = [<span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span>, <span class="mi">3</span>, <span class="mi">2</span>, <span class="mi">1</span>]</span></blockquote><blockquote class="alectryon-message"><span class="highlight">B = [<span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span>, <span class="mi">3</span>, <span class="mi">2</span>, <span class="mi">1</span>]</span></blockquote></div></div></small></span></pre><p>The two programs are equivalent, and indeed the latter is
elaborated into the former. Expressions between <tt class="docutils literal">{</tt> and <tt class="docutils literal">}</tt> are
said to be spilled out and placed just before the predicate
that contains them.</p>
<p>The <code class="highlight coq"><span class="name">calc</span></code> predicate is just a wrapper around the infix <code class="highlight coq"><span class="keyword reserved">is</span></code></p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk19"><span class="highlight">Elpi Query lp:{{ coq.say <span class="s2">&quot;result =&quot;</span> {calc (<span class="mi">2</span> + <span class="mi">3</span>)} }}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">result = <span class="mi">5</span></span></blockquote><blockquote class="alectryon-message"><span class="highlight">Query assignments:</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Spilled_1 = <span class="mi">5</span></span></blockquote></div></div></small></span></pre><p>Higher order predicates can be defined, but one has to be wary
of where variables are bound.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Accumulate lp:{{

pred bad i:list int, o:list int.

% Note that the standard library declares
%   pred std.map i:list A, i:(A -&gt; B -&gt; prop), o:list B.
% <span class="kn">Remark</span> <span class="s2">&quot;prop&quot;</span> <span class="kr">is</span> the <span class="kp">type of</span> predicates <span class="kn">and</span> that the type
% of <span class="s2">&quot;std.map&quot;</span> declared <span class="bp">by</span> the <span class="s2">&quot;pred&quot;</span> directive <span class="kr">is</span>
%   type std.map list A -&gt; (A -&gt; B -&gt; prop) -&gt; list B -&gt; prop
% Indeed <span class="s2">&quot;pred&quot;</span> extends a type declaration (<span class="kr">for</span> predicates,
% hence the trailing -&gt; prop <span class="kr">is</span> implicit) <span class="kr">with</span> a mode
% declaration <span class="kr">for</span> each argument.
bad L Result :-
  std.map L (x\ r\ TMP <span class="kr">is</span> x + <span class="mi">1</span>, r = TMP) Result.

pred good i:list int, o:list int.
good L Result :-
  std.map L good.aux Result.
good.aux X R :- TMP <span class="kr">is</span> X + <span class="mi">1</span>, R = TMP.

pred good2 i:list int, o:list int.
good2 L Result :-
  std.map L (x\ r\ sigma TMP\ TMP <span class="kr">is</span> x + <span class="mi">1</span>, r = TMP) Result.

}}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk1a"><span class="highlight">Elpi Query lp:{{

  not(bad [<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>] R1),
  good [<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>] R2,
  good2 [<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>] R3,
  coq.say R2 R3

}}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">[<span class="mi">2</span>, <span class="mi">3</span>, <span class="mi">4</span>] [<span class="mi">2</span>, <span class="mi">3</span>, <span class="mi">4</span>]</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Query assignments:</span></blockquote><blockquote class="alectryon-message"><span class="highlight">R1 = X0</span></blockquote><blockquote class="alectryon-message"><span class="highlight">R2 = [<span class="mi">2</span>, <span class="mi">3</span>, <span class="mi">4</span>]</span></blockquote><blockquote class="alectryon-message"><span class="highlight">R3 = [<span class="mi">2</span>, <span class="mi">3</span>, <span class="mi">4</span>]</span></blockquote></div></div></small></span></pre><p>The problem with <code class="highlight coq"><span class="name">bad</span></code> is that <code class="highlight coq"><span class="name">TMP</span></code> is fresh each time the clause
is used, but not every time the anonymous predicate passed to <code class="highlight coq"><span class="name">std</span><span class="operator">.</span><span class="name">map</span></code>
is used. Technically <code class="highlight coq"><span class="name">TMP</span></code> is quantified (allocated) where <code class="highlight coq"><span class="name">L</span></code> and <code class="highlight coq"><span class="name">Result</span></code>
are.</p>
<p>There are two ways to quantify <code class="highlight coq"><span class="name">TMP</span></code> correctly, that is inside the anonymous
predicate. One is to actually name the predicate. Another one is
to use the <code class="highlight coq"><span class="name">sigma</span></code> operator to allocate <code class="highlight coq"><span class="name">TMP</span></code> at every call.</p>
<p>One last way to skin the cat is to use <code class="highlight coq"><span class="operator">=&gt;</span></code> as follows. It gives us
the occasion to clarify further the scope of variables.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Accumulate lp:{{

pred good3 i:list int, o:list int.
good3 L Result :-
  (pi TMP X R\ good3.aux X R :- TMP <span class="kr">is</span> X + <span class="mi">1</span>, R = TMP) =&gt;
  std.map L good3.aux Result.

}}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk1b"><span class="highlight">Elpi Query lp:{{

  good3 [<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>] R,
  coq.say R

}}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">[<span class="mi">2</span>, <span class="mi">3</span>, <span class="mi">4</span>]</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Query assignments:</span></blockquote><blockquote class="alectryon-message"><span class="highlight">R = [<span class="mi">2</span>, <span class="mi">3</span>, <span class="mi">4</span>]</span></blockquote></div></div></small></span></pre><p>In this case the auxiliary predicate <code class="highlight coq"><span class="name">good3</span><span class="operator">.</span><span class="name">aux</span></code>
is only visible inside <code class="highlight coq"><span class="name">good3</span></code>.
What is interesting to remark is that the quantifications are explicit
in the hypothetical clause, and they indicate clearly that each and every
time <code class="highlight coq"><span class="name">good3</span><span class="operator">.</span><span class="name">aux</span></code> is used <code class="highlight coq"><span class="name">TMP</span></code>, <code class="highlight coq"><span class="name">X</span></code> and <code class="highlight coq"><span class="name">R</span></code> are fresh.</p>
<p>The <code class="highlight coq"><span class="name">pi</span></code> operator is dual to <code class="highlight coq"><span class="name">sigma</span></code>: since here it occurs negatively it
has the same meaning.</p>
<p>The last remark worth making is that bound variables are intimately related
to universal quantification, while unification variables are related to
existential quantification.  It goes without saying that the following
two queries are not equivalent and while the former is trivial the latter
is false:</p>
<div class="math">
\begin{align*}
\forall x, \exists Y, Y = x\\
\exists Y, \forall x, Y = x
\end{align*}
</div>
<p>Let's run these queries:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Query lp:{{ pi x\ sigma Y\ Y = x }}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk1c"><span class="highlight"><span class="kn">Fail</span> Elpi Query lp:{{ sigma Y\ pi x\ Y = x }}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">The command has indeed failed <span class="kr">with</span> message:
The elpi command function failed without giving a
specific error message. Please report this
inconvenience to the authors of the program.</span></blockquote></div></div></small></span></pre><p>Another way to put it: <code class="highlight coq"><span class="name">x</span></code> is in the scope of <code class="highlight coq"><span class="name">Y</span></code> only in the first formula,
hence <code class="highlight coq"><span class="name">x</span></code> can be assigned to <code class="highlight coq"><span class="name">Y</span></code> in that case only.</p>
<p>More in general, ŒªProlog tracks the bound variables that are in scope of each
unification variable. There are only two ways to put a bound variable
in the scope:</p>
<ul class="simple">
<li>quantify the unification variable under the bound one (first formula)</li>
<li>pass the bound variable to the unification variable explicitly: in this
the case the unification variable needs to have a functional type.
Indeed <span class="math">\(\exists Y, \forall x, (Y x) = x\)</span> has a solution: <code class="highlight coq"><span class="name">Y</span></code> can be the identity function.</li>
</ul>
<p>If we look again at the clause for type checking
lambda abstraction</p>
<pre class="code literal-block">
of (fun F) (arr A B) :-
  pi x\ of x A =&gt; of (F x) B.
</pre>
<p>we can read the scopes (recall all unification variables such as <code class="highlight coq"><span class="name">F</span></code>, <code class="highlight coq"><span class="name">A</span></code>, <code class="highlight coq"><span class="name">B</span></code> are
quantified upfront). The only unification variable that sees the fresh
<code class="highlight coq"><span class="name">x</span></code> is <code class="highlight coq"><span class="name">F</span></code>, because we pass <code class="highlight coq"><span class="name">x</span></code> to <code class="highlight coq"><span class="name">F</span></code> explicitly. Indeed when we write</p>
<div class="math">
\begin{equation*}
\frac{\Gamma, x : A \vdash f : B}{\Gamma \vdash \lambda x.f : A \rightarrow  B}
\end{equation*}
</div>
<p>on paper, the <code class="highlight coq"><span class="name">x</span></code> being bound can only occur in f (not in <code class="highlight coq"><span class="name">ùö™</span></code> or <code class="highlight coq"><span class="name">B</span></code> for example).
Remark that in the premise x is still bound, this time not by a Œª but by the
context <code class="highlight coq"><span class="name">ùö™</span><span class="operator">,</span> <span class="name">x</span> <span class="operator">:</span> <span class="name">A</span></code>. In ŒªProlog the context is the set of hypothetical clauses
and pi-quantified variables and is implicitly handled by the runtime of the
programming language.</p>
<p>A slogan to keep in mind is that:</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">There is not such as thing as a free variable!</p>
</div>
<p>and indeed the variable bound by the lambda abstraction (of our data) is
replaced by a fresh variable bound by the context (of our program). This is
called binder mobility. See also the paper 
<a class="reference external" href="https://hal.inria.fr/hal-01884210/">Mechanized metatheory revisited</a> by
Dale Miller which is an excellent
introduction to these concepts.</p>
</div>
<div class="section" id="debugging">
<h1><a class="toc-backref" href="#id5">Debugging</a></h1>
<p>A common ŒªProlog idiom is to have a debug clause
lying around.  The <code class="highlight coq"><span class="operator">:</span><span class="keyword reserved">if</span></code> attribute can be used to
make the clause conditionally interpreted (only if the
given debug variable is set).</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Debug <span class="s2">&quot;DEBUG_MYPRED&quot;</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Program <span class="kn">debug</span> lp:{{

  pred mypred i:int.

  :<span class="kr">if</span> <span class="s2">&quot;DEBUG_MYPRED&quot;</span> mypred X :-
    coq.say <span class="s2">&quot;calling mypred on &quot;</span> X, <span class="kp">fail</span>.

  mypred <span class="mi">0</span> :- coq.say <span class="s2">&quot;ok&quot;</span>.
  mypred M :- N <span class="kr">is</span> M - <span class="mi">1</span>, mypred N.

}}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk1d"><span class="highlight">Elpi Query lp:{{ mypred <span class="mi">3</span> }}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">calling mypred on  <span class="mi">3</span></span></blockquote><blockquote class="alectryon-message"><span class="highlight">calling mypred on  <span class="mi">2</span></span></blockquote><blockquote class="alectryon-message"><span class="highlight">calling mypred on  <span class="mi">1</span></span></blockquote><blockquote class="alectryon-message"><span class="highlight">calling mypred on  <span class="mi">0</span></span></blockquote><blockquote class="alectryon-message"><span class="highlight">ok</span></blockquote></div></div></small></span></pre><p>As a slightly more sophisticated debugging feature, the Elpi interpreter
provides tracing facilities.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Trace.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk1e"><span class="highlight">Elpi Query stlc lp:{{ % We run the query <span class="kr">in</span> the stlc program

  of (<span class="kr">fun</span> (<span class="nv">x</span>\ <span class="kr">fun</span> <span class="nv">y</span>\ x)) Ty, coq.say Ty

}}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">run <span class="mi">1</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">1</span> gid:<span class="mi">5</span> user:curgoal = of (<span class="kr">fun</span> <span class="nv">c0</span> \ <span class="kr">fun</span> <span class="nv">c1</span> \ c0) X0 , coq.say X0 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">1</span> gid:<span class="mi">5</span> user:rule = <span class="kn">and</span> 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">1</span> gid:<span class="mi">5</span> user:subgoal = <span class="mi">6</span> 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">1</span> gid:<span class="mi">6</span> user:newgoal = coq.say X0 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">1</span> gid:<span class="mi">5</span> user:subgoal = <span class="mi">7</span> 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">1</span> gid:<span class="mi">7</span> user:newgoal = of (<span class="kr">fun</span> <span class="nv">c0</span> \ <span class="kr">fun</span> <span class="nv">c1</span> \ c0) X0 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">run <span class="mi">2</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">2</span> gid:<span class="mi">7</span> user:curgoal = of (<span class="kr">fun</span> <span class="nv">c0</span> \ <span class="kr">fun</span> <span class="nv">c1</span> \ c0) X0 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">2</span> gid:<span class="mi">7</span> user:rule = backchain 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">2</span> gid:<span class="mi">7</span> user:candidates = File <span class="s2">&quot;(stdin)&quot;</span>, line <span class="mi">15</span>, column <span class="mi">582</span>, characters <span class="mi">980</span>-<span class="mi">1035</span>: 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">select <span class="mi">3</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">2</span> gid:<span class="mi">7</span> user:select = File <span class="s2">&quot;(stdin)&quot;</span>, line <span class="mi">15</span>, column <span class="mi">582</span>, characters <span class="mi">980</span>-<span class="mi">1035</span>: 
                                 of (<span class="kr">fun</span> <span class="nv">A0</span>) 
                                  (arr A1 A2) :- (pi (c0 \
                                                   (of c0 A1 =&gt; of (A0 c0) A2))). 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">2</span> gid:<span class="mi">0</span> user:assign = A0 := c0 \
                                 <span class="kr">fun</span> <span class="nv">c1</span> \ c0 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">2</span> gid:<span class="mi">0</span> user:assign = X0 := arr X1 X2 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">2</span> gid:<span class="mi">7</span> user:subgoal = <span class="mi">8</span> 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">2</span> gid:<span class="mi">8</span> user:newgoal = pi c0 \ of c0 X1 =&gt; of (<span class="kr">fun</span> <span class="nv">c1</span> \ c0) X2 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">run <span class="mi">3</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">3</span> gid:<span class="mi">8</span> user:curgoal = pi c0 \ of c0 X1 =&gt; of (<span class="kr">fun</span> <span class="nv">c1</span> \ c0) X2 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">3</span> gid:<span class="mi">8</span> user:rule = pi 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">3</span> gid:<span class="mi">8</span> user:subgoal = <span class="mi">9</span> 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">3</span> gid:<span class="mi">9</span> user:newgoal = of c0 X1 =&gt; of (<span class="kr">fun</span> <span class="nv">c1</span> \ c0) X2 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">run <span class="mi">4</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">4</span> gid:<span class="mi">9</span> user:curgoal = of c0 X1 =&gt; of (<span class="kr">fun</span> <span class="nv">c1</span> \ c0) X2 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">4</span> gid:<span class="mi">9</span> user:rule = implication 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">4</span> gid:<span class="mi">9</span> user:subgoal = <span class="mi">10</span> 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">4</span> gid:<span class="mi">10</span> user:newgoal = of (<span class="kr">fun</span> <span class="nv">c1</span> \ c0) X2 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">run <span class="mi">5</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">5</span> gid:<span class="mi">10</span> user:curgoal = of (<span class="kr">fun</span> <span class="nv">c1</span> \ c0) X2 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">5</span> gid:<span class="mi">10</span> user:rule = backchain 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">5</span> gid:<span class="mi">10</span> user:candidates = File <span class="s2">&quot;(stdin)&quot;</span>, line <span class="mi">15</span>, column <span class="mi">582</span>, characters <span class="mi">980</span>-<span class="mi">1035</span>: 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">select <span class="mi">4</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">5</span> gid:<span class="mi">10</span> user:select = File <span class="s2">&quot;(stdin)&quot;</span>, line <span class="mi">15</span>, column <span class="mi">582</span>, characters <span class="mi">980</span>-<span class="mi">1035</span>: 
                                  of (<span class="kr">fun</span> <span class="nv">A0</span>) 
                                   (arr A1 A2) :- (pi (c1 \
                                                    (of c0 A1 =&gt;
                                                      of (A0 c1) A2))). 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">5</span> gid:<span class="mi">0</span> user:assign = A0 := c1 \
                                 c0 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">5</span> gid:<span class="mi">0</span> user:assign = X2 := arr X3 X4 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">5</span> gid:<span class="mi">10</span> user:subgoal = <span class="mi">11</span> 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">5</span> gid:<span class="mi">11</span> user:newgoal = pi c1 \ of c1 X3 =&gt; of c0 X4 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">001</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">run <span class="mi">6</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">6</span> gid:<span class="mi">11</span> user:curgoal = pi c1 \ of c1 X3 =&gt; of c0 X4 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">6</span> gid:<span class="mi">11</span> user:rule = pi 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">6</span> gid:<span class="mi">11</span> user:subgoal = <span class="mi">12</span> 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">6</span> gid:<span class="mi">12</span> user:newgoal = of c1 X3 =&gt; of c0 X4 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">run <span class="mi">7</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">7</span> gid:<span class="mi">12</span> user:curgoal = of c1 X3 =&gt; of c0 X4 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">7</span> gid:<span class="mi">12</span> user:rule = implication 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">7</span> gid:<span class="mi">12</span> user:subgoal = <span class="mi">13</span> 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">7</span> gid:<span class="mi">13</span> user:newgoal = of c0 X4 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">run <span class="mi">8</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">8</span> gid:<span class="mi">13</span> user:curgoal = of c0 X4 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">8</span> gid:<span class="mi">13</span> user:rule = backchain 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">8</span> gid:<span class="mi">13</span> user:candidates = hypothetical clause: of c0 X1 :- . 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">select <span class="mi">5</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">8</span> gid:<span class="mi">13</span> user:select =  
                                  of c0 X1 :- . 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">8</span> gid:<span class="mi">0</span> user:assign = X1 := X4 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">run <span class="mi">9</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">9</span> gid:<span class="mi">6</span> user:curgoal = coq.say (arr X4 (arr X3 X4)) 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">9</span> gid:<span class="mi">6</span> user:rule = builtin 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">arr X4 (arr X3 X4)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">0</span> step:<span class="mi">9</span> gid:<span class="mi">6</span> user:builtin = success 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Query assignments:</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Ty = arr X4 (arr X3 X4)</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk1f"><span class="highlight"><span class="kn">Fail</span> Elpi Query stlc lp:{{

  of (<span class="kr">fun</span> (<span class="nv">x</span>\ app x x)) Ty, coq.say Ty

}}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">run <span class="mi">1</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">1</span> gid:<span class="mi">14</span> user:curgoal = of (<span class="kr">fun</span> <span class="nv">c0</span> \ app c0 c0) X0 , coq.say X0 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">1</span> gid:<span class="mi">14</span> user:rule = <span class="kn">and</span> 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">1</span> gid:<span class="mi">14</span> user:subgoal = <span class="mi">15</span> 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">1</span> gid:<span class="mi">15</span> user:newgoal = coq.say X0 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">1</span> gid:<span class="mi">14</span> user:subgoal = <span class="mi">16</span> 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">1</span> gid:<span class="mi">16</span> user:newgoal = of (<span class="kr">fun</span> <span class="nv">c0</span> \ app c0 c0) X0 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">run <span class="mi">2</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">2</span> gid:<span class="mi">16</span> user:curgoal = of (<span class="kr">fun</span> <span class="nv">c0</span> \ app c0 c0) X0 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">2</span> gid:<span class="mi">16</span> user:rule = backchain 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">2</span> gid:<span class="mi">16</span> user:candidates = File <span class="s2">&quot;(stdin)&quot;</span>, line <span class="mi">15</span>, column <span class="mi">582</span>, characters <span class="mi">980</span>-<span class="mi">1035</span>: 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">select <span class="mi">3</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">2</span> gid:<span class="mi">16</span> user:select = File <span class="s2">&quot;(stdin)&quot;</span>, line <span class="mi">15</span>, column <span class="mi">582</span>, characters <span class="mi">980</span>-<span class="mi">1035</span>: 
                                  of (<span class="kr">fun</span> <span class="nv">A0</span>) 
                                   (arr A1 A2) :- (pi (c0 \
                                                    (of c0 A1 =&gt;
                                                      of (A0 c0) A2))). 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">2</span> gid:<span class="mi">0</span> user:assign = A0 := c0 \
                                 app c0 c0 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">2</span> gid:<span class="mi">0</span> user:assign = X0 := arr X1 X2 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">2</span> gid:<span class="mi">16</span> user:subgoal = <span class="mi">17</span> 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">2</span> gid:<span class="mi">17</span> user:newgoal = pi c0 \ of c0 X1 =&gt; of (app c0 c0) X2 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">run <span class="mi">3</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">3</span> gid:<span class="mi">17</span> user:curgoal = pi c0 \ of c0 X1 =&gt; of (app c0 c0) X2 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">3</span> gid:<span class="mi">17</span> user:rule = pi 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">3</span> gid:<span class="mi">17</span> user:subgoal = <span class="mi">18</span> 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">3</span> gid:<span class="mi">18</span> user:newgoal = of c0 X1 =&gt; of (app c0 c0) X2 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">run <span class="mi">4</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">4</span> gid:<span class="mi">18</span> user:curgoal = of c0 X1 =&gt; of (app c0 c0) X2 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">4</span> gid:<span class="mi">18</span> user:rule = implication 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">4</span> gid:<span class="mi">18</span> user:subgoal = <span class="mi">19</span> 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">4</span> gid:<span class="mi">19</span> user:newgoal = of (app c0 c0) X2 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">run <span class="mi">5</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">5</span> gid:<span class="mi">19</span> user:curgoal = of (app c0 c0) X2 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">5</span> gid:<span class="mi">19</span> user:rule = backchain 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">5</span> gid:<span class="mi">19</span> user:candidates = File <span class="s2">&quot;(stdin)&quot;</span>, line <span class="mi">10</span>, column <span class="mi">578</span>, characters <span class="mi">801</span>-<span class="mi">852</span>: 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">select <span class="mi">4</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">5</span> gid:<span class="mi">19</span> user:select = File <span class="s2">&quot;(stdin)&quot;</span>, line <span class="mi">10</span>, column <span class="mi">578</span>, characters <span class="mi">801</span>-<span class="mi">852</span>: 
                                  of (app A0 A1) A2 :- (of A0 (arr A3 A2)), 
                                   (of A1 A3). 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">5</span> gid:<span class="mi">0</span> user:assign = A0 := c0 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">5</span> gid:<span class="mi">0</span> user:assign = A1 := c0 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">5</span> gid:<span class="mi">0</span> user:assign = A2 := X2 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">5</span> gid:<span class="mi">19</span> user:subgoal = <span class="mi">20</span> 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">5</span> gid:<span class="mi">20</span> user:newgoal = of c0 X3^<span class="mi">1</span> 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">5</span> gid:<span class="mi">19</span> user:subgoal = <span class="mi">21</span> 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">5</span> gid:<span class="mi">21</span> user:newgoal = of c0 (arr X3^<span class="mi">1</span> X2) 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">run <span class="mi">6</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">6</span> gid:<span class="mi">21</span> user:curgoal = of c0 (arr X3^<span class="mi">1</span> X2) 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">6</span> gid:<span class="mi">21</span> user:rule = backchain 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">6</span> gid:<span class="mi">21</span> user:candidates = hypothetical clause: of c0 X1 :- . 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">select <span class="mi">5</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">6</span> gid:<span class="mi">21</span> user:select =  
                                  of c0 X1 :- . 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">6</span> gid:<span class="mi">0</span> user:assign(expand) = X3^<span class="mi">1</span> := X4 c0 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">6</span> gid:<span class="mi">0</span> user:assign(restrict) = <span class="mi">0</span> X4 c0 := c0 \
                                           .X5 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">6</span> gid:<span class="mi">0</span> user:assign = X1 := arr X5 X2 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">run <span class="mi">7</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">7</span> gid:<span class="mi">20</span> user:curgoal = of c0 X5 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">7</span> gid:<span class="mi">20</span> user:rule = backchain 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">7</span> gid:<span class="mi">20</span> user:candidates = hypothetical clause: of c0 
                                                            (arr X5 X2) :- . 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">select <span class="mi">6</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">7</span> gid:<span class="mi">20</span> user:select =  
                                  of c0 (arr X5 X2) :- . 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">7</span> gid:<span class="mi">20</span> user:select = <span class="kp">fail</span> to <span class="nb">unify</span>: .&lt;&lt;c0 \ .X5&gt;_0 c0&gt;_1
                                    <span class="kr">with</span> .&lt;arr .X5 .X2&gt;_0 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">select <span class="mi">7</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">1</span> step:<span class="mi">7</span> gid:<span class="mi">20</span> user:select = <span class="kp">fail</span> 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">The command has indeed failed <span class="kr">with</span> message:
The elpi command stlc failed without giving a specific
error message. Please report this inconvenience to the
authors of the program.</span></blockquote></div></div></small></span></pre><p>The trace can be limited to a range of steps. Look at the
numbers <tt class="docutils literal">run HERE {{{</tt>.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Trace <span class="mi">6</span> <span class="mi">8</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk20"><span class="highlight">Elpi Query stlc lp:{{

  of (<span class="kr">fun</span> (<span class="nv">x</span>\ <span class="kr">fun</span> <span class="nv">y</span>\ x)) Ty, coq.say Ty

}}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">run <span class="mi">6</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">2</span> step:<span class="mi">6</span> gid:<span class="mi">28</span> user:curgoal = pi c1 \ of c1 X0 =&gt; of c0 X1 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">2</span> step:<span class="mi">6</span> gid:<span class="mi">28</span> user:rule = pi 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">2</span> step:<span class="mi">6</span> gid:<span class="mi">28</span> user:subgoal = <span class="mi">29</span> 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">2</span> step:<span class="mi">6</span> gid:<span class="mi">29</span> user:newgoal = of c1 X0 =&gt; of c0 X1 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">run <span class="mi">7</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">2</span> step:<span class="mi">7</span> gid:<span class="mi">29</span> user:curgoal = of c1 X0 =&gt; of c0 X1 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">2</span> step:<span class="mi">7</span> gid:<span class="mi">29</span> user:rule = implication 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">2</span> step:<span class="mi">7</span> gid:<span class="mi">29</span> user:subgoal = <span class="mi">30</span> 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">2</span> step:<span class="mi">7</span> gid:<span class="mi">30</span> user:newgoal = of c0 X1 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">run <span class="mi">8</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">2</span> step:<span class="mi">8</span> gid:<span class="mi">30</span> user:curgoal = of c0 X1 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">2</span> step:<span class="mi">8</span> gid:<span class="mi">30</span> user:rule = backchain 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">2</span> step:<span class="mi">8</span> gid:<span class="mi">30</span> user:candidates = hypothetical clause: of c0 X2 :- . 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">select <span class="mi">5</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">2</span> step:<span class="mi">8</span> gid:<span class="mi">30</span> user:select =  
                                  of c0 X2 :- . 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">2</span> step:<span class="mi">8</span> gid:<span class="mi">0</span> user:assign = X2 := X1 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">arr X1 (arr X0 X1)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Query assignments:</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Ty = arr X1 (arr X0 X1)</span></blockquote></div></div></small></span></pre><p>The trace can be limited to a (list of) predicates as follows:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Trace <span class="s2">&quot;of&quot;</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk21"><span class="highlight">Elpi Query stlc lp:{{

  of (<span class="kr">fun</span> (<span class="nv">x</span>\ <span class="kr">fun</span> <span class="nv">y</span>\ x)) Ty, coq.say Ty

}}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">run <span class="mi">2</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">3</span> step:<span class="mi">2</span> gid:<span class="mi">33</span> user:curgoal = of (<span class="kr">fun</span> <span class="nv">c0</span> \ <span class="kr">fun</span> <span class="nv">c1</span> \ c0) X0 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">3</span> step:<span class="mi">2</span> gid:<span class="mi">33</span> user:rule = backchain 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">3</span> step:<span class="mi">2</span> gid:<span class="mi">33</span> user:candidates = File <span class="s2">&quot;(stdin)&quot;</span>, line <span class="mi">15</span>, column <span class="mi">582</span>, characters <span class="mi">980</span>-<span class="mi">1035</span>: 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">select <span class="mi">3</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">3</span> step:<span class="mi">2</span> gid:<span class="mi">33</span> user:select = File <span class="s2">&quot;(stdin)&quot;</span>, line <span class="mi">15</span>, column <span class="mi">582</span>, characters <span class="mi">980</span>-<span class="mi">1035</span>: 
                                  of (<span class="kr">fun</span> <span class="nv">A0</span>) 
                                   (arr A1 A2) :- (pi (c0 \
                                                    (of c0 A1 =&gt;
                                                      of (A0 c0) A2))). 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">3</span> step:<span class="mi">2</span> gid:<span class="mi">0</span> user:assign = A0 := c0 \
                                 <span class="kr">fun</span> <span class="nv">c1</span> \ c0 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">3</span> step:<span class="mi">2</span> gid:<span class="mi">0</span> user:assign = X0 := arr X1 X2 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">3</span> step:<span class="mi">2</span> gid:<span class="mi">33</span> user:subgoal = <span class="mi">34</span> 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">3</span> step:<span class="mi">2</span> gid:<span class="mi">34</span> user:newgoal = pi c0 \ of c0 X1 =&gt; of (<span class="kr">fun</span> <span class="nv">c1</span> \ c0) X2 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">run <span class="mi">5</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">3</span> step:<span class="mi">5</span> gid:<span class="mi">36</span> user:curgoal = of (<span class="kr">fun</span> <span class="nv">c1</span> \ c0) X2 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">3</span> step:<span class="mi">5</span> gid:<span class="mi">36</span> user:rule = backchain 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">3</span> step:<span class="mi">5</span> gid:<span class="mi">36</span> user:candidates = File <span class="s2">&quot;(stdin)&quot;</span>, line <span class="mi">15</span>, column <span class="mi">582</span>, characters <span class="mi">980</span>-<span class="mi">1035</span>: 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">select <span class="mi">4</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">3</span> step:<span class="mi">5</span> gid:<span class="mi">36</span> user:select = File <span class="s2">&quot;(stdin)&quot;</span>, line <span class="mi">15</span>, column <span class="mi">582</span>, characters <span class="mi">980</span>-<span class="mi">1035</span>: 
                                  of (<span class="kr">fun</span> <span class="nv">A0</span>) 
                                   (arr A1 A2) :- (pi (c1 \
                                                    (of c0 A1 =&gt;
                                                      of (A0 c1) A2))). 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">3</span> step:<span class="mi">5</span> gid:<span class="mi">0</span> user:assign = A0 := c1 \
                                 c0 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">3</span> step:<span class="mi">5</span> gid:<span class="mi">0</span> user:assign = X2 := arr X3 X4 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">3</span> step:<span class="mi">5</span> gid:<span class="mi">36</span> user:subgoal = <span class="mi">37</span> 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">3</span> step:<span class="mi">5</span> gid:<span class="mi">37</span> user:newgoal = pi c1 \ of c1 X3 =&gt; of c0 X4 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">run <span class="mi">8</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">3</span> step:<span class="mi">8</span> gid:<span class="mi">39</span> user:curgoal = of c0 X4 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">3</span> step:<span class="mi">8</span> gid:<span class="mi">39</span> user:rule = backchain 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">3</span> step:<span class="mi">8</span> gid:<span class="mi">39</span> user:candidates = hypothetical clause: of c0 X1 :- . 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">select <span class="mi">5</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">3</span> step:<span class="mi">8</span> gid:<span class="mi">39</span> user:select =  
                                  of c0 X1 :- . 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">3</span> step:<span class="mi">8</span> gid:<span class="mi">0</span> user:assign = X1 := X4 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">arr X4 (arr X3 X4)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Query assignments:</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Ty = arr X4 (arr X3 X4)</span></blockquote></div></div></small></span></pre><p>One can combine the range of steps with the predicate:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Trace <span class="mi">6</span> <span class="mi">8</span> <span class="s2">&quot;of&quot;</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk22"><span class="highlight">Elpi Query stlc lp:{{

  of (<span class="kr">fun</span> (<span class="nv">x</span>\ <span class="kr">fun</span> <span class="nv">y</span>\ x)) Ty, coq.say Ty

}}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">run <span class="mi">8</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">4</span> step:<span class="mi">8</span> gid:<span class="mi">48</span> user:curgoal = of c0 X0 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">4</span> step:<span class="mi">8</span> gid:<span class="mi">48</span> user:rule = backchain 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">4</span> step:<span class="mi">8</span> gid:<span class="mi">48</span> user:candidates = hypothetical clause: of c0 X1 :- . 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">select <span class="mi">5</span> {{{  
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">4</span> step:<span class="mi">8</span> gid:<span class="mi">48</span> user:select =  
                                  of c0 X1 :- . 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">rid:<span class="mi">4</span> step:<span class="mi">8</span> gid:<span class="mi">0</span> user:assign = X1 := X0 
</span></blockquote><blockquote class="alectryon-message"><span class="highlight">}}} -&gt;  (<span class="mi">0</span>.<span class="mi">000</span>s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">arr X0 (arr X2 X0)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Query assignments:</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Ty = arr X0 (arr X2 X0)</span></blockquote></div></div></small></span></pre><p>To switch traces off:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Trace Off.</span></span></span></pre><p>Given that programs are not written in a single place, but rather obtained by
accumulating code, Elpi is able to print a (full) program to an html file
as follows. The obtained file provides a facility to filter clauses by their
predicate.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi <span class="kn">Print</span> stlc <span class="s2">&quot;stlc.html&quot;</span>.</span></span></span></pre><p>Look at the <a class="reference external" href="https://lpcic.github.io/coq-elpi/stlc.html">generated page</a>
and type <code class="highlight coq"><span class="name">of</span></code> in the filter.</p>
<p>Finally, one can bound the number of backchaining steps
performed by the interpreter:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Query lp:{{ <span class="mi">0</span> = <span class="mi">0</span>, <span class="mi">1</span> = <span class="mi">1</span> }}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Bound Steps <span class="mi">1</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-elpi-lang-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-elpi-lang-v-chk23"><span class="highlight"><span class="kn">Fail</span> Elpi Query lp:{{ <span class="mi">0</span> = <span class="mi">0</span>, <span class="mi">1</span> = <span class="mi">1</span> }}. <span class="c">(* it needs more than 1 step! *)</span></span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">The command has indeed failed <span class="kr">with</span> message:
elpi run out of steps (<span class="mi">1</span>)</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Bound Steps <span class="mi">0</span>. <span class="c">(* Go back to no bound *)</span></span></span></span></pre></div>
<div class="section" id="further-reading">
<h1><a class="toc-backref" href="#id6">Further reading</a></h1>
<p>The <a class="reference external" href="http://www.lix.polytechnique.fr/~dale/lProlog/">ŒªProlog website</a>
contains useful links to ŒªProlog related material.</p>
<p>Papers and other documentation about Elpi can be found at
the <a class="reference external" href="https://github.com/LPCIC/elpi/">Elpi home on github</a>.</p>
<p>Three more tutorials specific to Elpi as an extension language for Coq
can be found in the <a class="reference external" href="https://github.com/LPCIC/coq-elpi/blob/master/examples/">examples folder</a>.</p>
<script>
var style = document.createElement('style');
style.textContent = `
  .alectryon-io {
     border-left-style: solid;
     border-left-color: lightgrey;
     padding-left: 1em;
     margin-left: 1em;
  }
  code.coq {
     border-style: solid;
     border-color: lightgrey;
     border-width: 0.1em;
     padding: 0.2em 0.3em 0.2em 0.3em;
     border-radius: 0.5em
  }
  body {
    line-height: 2;
  }
  div.warning , div.important, div.warning, div.note {
     border-style: solid;
     border-color: lightgrey;
     border-width: 0.1em;
     border-radius: 0.5em
  }
`;
document.getElementsByTagName('head')[0].appendChild(style);
</script></div>
</div>
</div>
</div></body>
</html>

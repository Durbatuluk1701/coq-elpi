% returns the classes on which the current gref depends
pred get-sub-classes i:gref, o:list gref.
get-sub-classes GR Res :-
  coq.env.dependencies GR _ DepSet,
  coq.gref.set.elements DepSet DepList,
  std.filter DepList coq.TC.class? Res.

% takes a type of an isntance, the instance and two empty lists.
% returns a new tc clause corresponding to the current instance.
% note that every quantified variable V should be quantified with
% pi variables and if V contains an instance assumption,
% then V should be added to the hypothesis of the final clause.
pred compile-aux i:term, i:term, i:list prop, i:list term, i:list term, o:prop, o:bool.
compile-aux Ty I [] [] [X | XS] (pi x\ C x) Bool :- !,
    pi x\ copy X x => copy Ty (Ty1 x),
    compile-aux (Ty1 x) I [] [] XS (C x) Bool.
compile-aux (prod _ T F) I ListRHS ListVar [] (pi x\ C x) ff:-
  pi p cond\ sigma Clause L\ 
  % decl cond _ T => 
    if (app-has-class T) (compile-aux T p [] [] [] Clause _, L = [Clause | ListRHS]) (L = ListRHS),
    compile-aux (F p) I L [p | ListVar] [] (C p) _.
compile-aux Ty I ListRHS ListVar [] Clause tt :- 
  % if (ListRHS = []) (IsLeaf = tt) (IsLeaf = ff), 
  std.rev ListRHS RevRHS,
  coq.mk-app I {std.rev ListVar} AppInst,
  make-tc Ty AppInst RevRHS Clause.

pred compile-ty i:term, i:term, o:bool, o:gref, o:prop.
compile-ty Ty Inst IsLeaf TC-of-Inst Clause:-
  get-TC-of-inst-type Ty TC-of-Inst,
  @redflags! coq.redflags.beta => coq.reduction.lazy.norm Ty Ty1, 
  coq.univ.variable.set.elements {coq.univ.variable.of-term Ty} L,
  std.map L (x\r\ sigma P\ coq.univ.variable P x, r = sort (typ P)) L1,
  compile-aux Ty1 Inst [] [] L1 Clause IsLeaf.

pred compile i:gref, o:bool, o:gref, o:prop.
compile InstGR IsLeaf TC-of-Inst Clause:-
  coq.env.typeof InstGR Ty,
  compile-ty Ty (global InstGR) IsLeaf TC-of-Inst Clause.

% if an instance depends on multiple TC then a warning is raised.
pred warn-multiple-deps i:gref, i:list gref.
warn-multiple-deps Inst Dep :-
  if (fail, {std.length Dep} > 1) (
    coq.warning "add-inst-with-multiple-deps"  "TC-warning"
    "Adding" Inst "which dependes on mulitple class dependencies:" Dep) 
    true.

pred has-context-deps i:gref.
has-context-deps GR :-
  coq.env.section SectionVars,
  coq.env.dependencies GR _ Deps, 
  std.exists SectionVars (x\ coq.gref.set.mem (const x) Deps).

% [add-inst->db IgnoreClassDepL Inst] add the Inst to
% the database except those depending on at least one 
% inside IgnoreClassDepL
pred add-inst->db i:list gref, i:bool, i:gref.
add-inst->db IgnoreClassDepL ForceAdd Inst :-
  coq.env.current-section-path SectionPath,
  get-sub-classes Inst Dep,
  warn-multiple-deps Inst Dep,
  if ((ForceAdd = tt; not (instance _ Inst _)), 
    not (std.exists Dep (std.mem IgnoreClassDepL))) 
  (
    % TODO: HERE WE IGNORE THE PGLOBAL INST 
    if (compile Inst _IsLeaf TC-of-Inst Clause)(
      % if (IsLeaf = tt) (Graft = "leafHook") (Graft = "withPremisesHook"),
      Graft is int_to_string {get-inst-prio Inst},
      add-tc-db _ (after Graft) Clause,
      if (has-context-deps Inst) 
        (@local! => add-tc-db _ _ (instance SectionPath Inst TC-of-Inst)) 
        (add-tc-db _ _ (instance [] Inst TC-of-Inst))) true
  ) 
  true.

pred add-tc i:list gref, i:list gref, i:gref.
add-tc IgnoreDepClassGR IgnoreInstsGR GR:-
  add-modes GR, 
  get-inst-by-tc-name GR InstL,
  std.filter InstL (x\ not (std.mem IgnoreInstsGR x)) InstLF,
  std.forall InstLF (add-inst->db IgnoreDepClassGR ff).

pred add-tc-or-inst-gr i:list string, i:list string, i:list gref.
add-tc-or-inst-gr IgnoreDepClass IgnoreInsts Names :-
  std.map IgnoreDepClass coq.locate IgnoreDepClassGR,
  std.map IgnoreInsts coq.locate IgnoreInstsGR,
  std.forall Names (GR\
    if2 (coq.TC.class? GR)(add-tc IgnoreDepClassGR IgnoreInstsGR GR)
        (is-instance-gr GR)(add-inst->db IgnoreDepClassGR ff GR)
        (coq.warning "not-inst-nor-tc" "TC-warning" GR "is neither a TC nor a instance")
  ).

% [add-tc-or-inst IgnoreDepClass ClassName] look
% for all the instances of ClassName and call the pred
% add-inst->db
pred add-tc-or-inst i:list string, i:list string, i:list string.
add-tc-or-inst IgnoreDepClass IgnoreInsts Names :-
  std.map Names coq.locate L,
  add-tc-or-inst-gr IgnoreDepClass IgnoreInsts L.

% takes a Path and a GR and returns if 
% the GR is located in Path
pred is-in-path i:string, i:gref. 
is-in-path Path GR :- 
  std.mem {coq.gref->path GR} Path.

% Look for the instances of ClassName 
% that are located in Path.
pred add-path i:string, i:string.
add-path ClassName Path :-
  coq.locate ClassName GR,
  std.filter {get-inst-by-tc-name GR} (is-in-path Path) InstInPath,
  std.forall InstInPath (add-inst->db [] ff).
pred classes i:gref.

pred bool->mode-term i:bool, o:string.
bool->mode-term tt "i:term".
bool->mode-term ff "o:term".

pred modes->string i:list bool, o:string.
modes->string L S :-
  std.map L bool->mode-term L',
  std.string.concat "," L' S.

pred fail->bool i:prop, o:bool.
fail->bool P ff :- P, !.
fail->bool _ tt.

pred make-tc-modes i:int, o:string.
make-tc-modes NB_args ModesStr :-
  list-init NB_args (x\r\ fail->bool (x = 1) r) ModesBool,
  modes->string ModesBool ModesStr.

pred split-dot i:string, o:list string.
split-dot S R :- rex.split "\." S R.

pred split-dot-last i:string, o:string.
split-dot-last S R :- std.last {split-dot S} R.

pred gref->string-no-path i:gref, o:string.
gref->string-no-path Gr S :-
  coq.gref->string Gr Str, split-dot-last Str S',
  S is "tc-" ^ S'.

pred add-tc-pred i:gref, i:int.
add-tc-pred Gr NbArgs :-
  not (classes Gr),
  make-tc-modes NbArgs Modes, 
  gref->string-no-path Gr GrStr,
  D is "pred " ^ GrStr ^ " " ^ Modes ^ ".",
  coq.elpi.add-predicate "tc.db" D,
  coq.elpi.accumulate _ "tc.db" (clause _ _ (classes Gr)).
add-tc-pred _ _.

pred tc i:gref, i:term, o:term. 
pred make-tc i:term, i:term, i:list prop, o:prop.
make-tc Ty Inst Hyp Clause :-
  app [global TC | TL] = Ty,
  gref->string-no-path TC TC_Str,
  std.append TL [Inst] Args, 
  std.length Args ArgsLen,
  add-tc-pred TC ArgsLen,
  coq.elpi.predicate TC_Str Args Q,
  Clause = (Q :- Hyp).

pred app-has-class i:term, o:gref.
app-has-class (prod _ _ T) C :- pi x\ app-has-class (T x) C.
app-has-class (app [global T|_]) T :- coq.TC.class? T. 
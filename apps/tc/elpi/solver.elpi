/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

accumulate base.

% Temporary hack, to disable the next declare evar
pred declare-evar-after-refine.

% We want to deactivate the evar declaration if coming from the
% original goal (the original type class problem to be solved)
% :before "default-declare-evar"
% :name "tc-solver-declare-evar"
% declare-evar _Ctx X Ty E :-
%   coq.say "X TY E" X Ty E,
%   not declare-evar-after-refine,
%   (not (is-instance-term Ty)), !.

pred time-solve i:prop.
time-solve P :-
  std.time P Time,
  if-true (is-option-active oTC-time) 
    (coq.say "[TC] Total resolution time is:" Time).

pred is-reversed.

msolve L N :- is-reversed, !,
  time-solve (coq.ltac.all (coq.ltac.open solve-aux) {std.rev L} N).

msolve L N :- !, 
  time-solve (coq.ltac.all (coq.ltac.open solve-aux) L N).

% solve A L :- time-solve (solve-aux A L).

% [section-var->decl.aux L R] auxiliary function for `section-var->decl`
pred section-var->decl.aux i:list constant, o:list prop.
section-var->decl.aux [] [].
section-var->decl.aux [X|XS] [Y|YS] :-
  coq.env.typeof (const X) Ty,
  Y = (decl (global (const X)) _ Ty),
  section-var->decl.aux XS YS.

% [section-var->decl L] decl representing seciton variables with their types
pred section-var->decl o:list prop.
section-var->decl L :-
  section-var->decl.aux {coq.env.section} L.

% [build-hypotheses Ctx Hyps] returns the list of hypotheses, made of the
% variables in the context and the current section
pred build-hypotheses i:list prop, o:list prop.
:name "build-hypotheses"
build-hypotheses Ctx Clauses :-
  std.append Ctx {section-var->decl} CtxAndSection,
  compile-ctx CtxAndSection Clauses. 

% [tc-recursive-search Goal Solution] takes the type of the goal and solves it
pred tc-recursive-search i:term, o:term.
tc-recursive-search T Proof :- 
  std.time (
    std.do![
      modes-check T, !,
      ho-preprocess T Ty PostProcess,
      coq.safe-dest-app Ty (global TC) TL',
      std.append TL' [Proof] TL,
      coq.elpi.predicate {gref->pred-name TC} TL Q
      ], 
    do [Q | PostProcess]
  ) Time,
  if-true (is-option-active oTC-time-instance-search) 
    (coq.say "[TC] Instance search time is:" Time).

pred refine-proof i:term, i:goal, o:list sealed-goal.
refine-proof Proof G GL :-
  if (is-option-active oTC-ignore-eta-reduction) 
    (Proof' = Proof) (coq.reduction.eta-contract Proof Proof'),
  std.time (refine Proof' G GL) Refine-Time,              % <-- Here the refine
  if-true (print-solution) (coq.say "The proof is <<<" Proof ">>>"),
  if-true (is-option-active oTC-time-refine) 
    (coq.say "[TC] Refine time is:" Refine-Time).
refine-proof Proof _ _:-
  coq.error "illtyped solution:" {coq.term->string Proof}.

pred solve-aux i:goal, o:list sealed-goal.
:name "solve-aux-intros"
solve-aux (goal _ _ (prod N _ _) _ _ as G) GL :- !,
  refine (fun N _ _) G GL1,
  coq.ltac.all (coq.ltac.open solve-aux) GL1 GL.

:name "solve-aux-conclusion"
solve-aux (goal Ctx _ TyRaw Sol _ as G) GL :-
  var Sol,
  build-hypotheses Ctx CtxClause,
  do-once (normalize-ty TyRaw Ty),
  if-true print-goal (coq.say "The goal is <<<" Ty ">>>"),
  declare-evar-after-refine => CtxClause => (
    tc-recursive-search Ty Proof,
    refine-proof Proof G GL
  ).
:name "solve-aux-fail"
solve-aux (goal _ _ Ty _ _) _ :-
  coq.ltac.fail _ "[TC] fail to solve" Ty.


pred print-solution.
pred print-goal.

main _.
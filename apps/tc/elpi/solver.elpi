/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

accumulate base.

% Temporary hack, to disable the next declare evar
pred declare-evar-after-refine.

% We want to deactivate the evar declaration if coming from the
% original goal (the original type class problem to be solved)
:before "default-declare-evar"
:name "tc-solver-declare-evar"
declare-evar _ _ Ty _ :-
  not declare-evar-after-refine,
  (not (is-instance-term Ty)), !.

pred time-solve i:prop.
time-solve P :-
  std.time P Time,
  if-true (is-option-active oTC-time) 
    (coq.say "[TC] Total resolution time is:" Time).

pred is-reversed.

msolve L N :- is-reversed, !,
  time-solve (coq.ltac.all (coq.ltac.open solve-aux) {std.rev L} N).

msolve L N :- !, 
  time-solve (coq.ltac.all (coq.ltac.open solve-aux) L N).

% solve A L :- time-solve (solve-aux A L).

% [section-var->decl.aux L R] auxiliary function for `section-var->decl`
pred section-var->decl.aux i:list constant, o:list prop.
section-var->decl.aux [] [].
section-var->decl.aux [X|XS] [Y|YS] :-
  coq.env.typeof (const X) Ty,
  Y = (decl (global (const X)) _ Ty),
  section-var->decl.aux XS YS.

% [section-var->decl L] decl representing seciton variables with their types
pred section-var->decl o:list prop.
section-var->decl L :-
  section-var->decl.aux {coq.env.section} L.

% [build-hypotheses Ctx Hyps] returns the list of hypotheses, made of the
% variables in the context and the current section
pred build-hypotheses i:list prop, o:list prop.
:name "build-hypotheses"
build-hypotheses Ctx Clauses :-
  std.append Ctx {section-var->decl} CtxAndSection,
  compile-ctx CtxAndSection Clauses. 

% [tc-recursive-search Goal Solution] takes the type of the goal and solves it
pred tc-recursive-search i:term, o:term.
tc-recursive-search T Proof :- 
  std.time (
    std.do![
      modes-check T, !,
      ho-preprocess T Ty PostProcess,
      coq.safe-dest-app Ty (global TC) TL',
      std.append TL' [Proof] TL,
      coq.elpi.predicate {gref->pred-name TC} TL Q
      ], 
    do [Q | PostProcess]
  ) Time,
  if-true (is-option-active oTC-time-instance-search) 
    (coq.say "[TC] Instance search time is:" Time).

:if "solve-print-goal"
solve-aux (goal Ctx _ Ty _ _) _ :-
  coq.say "Ctx" Ctx "Ty" Ty, fail.

pred solve-aux i:goal, o:list sealed-goal.
solve-aux (goal _ _ (prod N _ _) _ _ as G) GL :- !,
  refine (fun N _ _) G GL1,
  coq.ltac.all (coq.ltac.open solve-aux) GL1 GL.
:name "solve-aux-base"
solve-aux (goal Ctx _ TyRaw Sol _ as G) GL :-
  var Sol,
  build-hypotheses Ctx Clauses, !,
  normalize-ty TyRaw Ty, !,
  if-true (print-goal) (coq.say "The goal is <<<" Ty ">>>"),
  declare-evar-after-refine => Clauses => if (tc-recursive-search Ty Proof) 
    (
      if-true (print-solution) (coq.say "The proof is <<<" Proof ">>>"),
      if (is-option-active oTC-ignore-eta-reduction) 
        (Proof' = Proof) (coq.reduction.eta-contract Proof Proof'),
      std.time (refine Proof' G GL) Refine-Time, 
      if-true (is-option-active oTC-time-refine) 
        (coq.say "[TC] Refine time is:" Refine-Time);
      coq.error "illtyped solution:" {coq.term->string Proof}
    ) 
    (coq.ltac.fail _ "[TC] fail to solve" Ty).



pred print-solution.
:name "print-solution"
print-solution :- fail.

pred print-goal.
:name "print-goal"
print-goal :- fail.

main _.
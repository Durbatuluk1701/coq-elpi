msolve L N :- !,
  coq.ltac.all (coq.ltac.open solve) {std.rev L} N.

pred my-refine i:term, i:goal, o:(list sealed-goal).
% :if "time-refine"
my-refine T G GL :- !, std.time(refine T G GL) FF, 
  if (coq.option.get ["TimeRefine"] (coq.option.bool tt)) (coq.say "Refine Time" FF) true.
% my-refine T G GL :- refine T G GL.

pred tc-search-time i:gref, i:term, o:term.
% :if "time-tc"
tc-search-time TC Ty X :- !,
  std.time (tc TC Ty X) Time,
  if (coq.option.get ["TimeTC"] (coq.option.bool tt)) (coq.say "TC search" Time) true.
% tc-search-time TC Ty X :- tc TC Ty X.

pred build-context-clauses i:list prop, o:list prop.
% Add the section's definition to the given context
% and atomize context hypothesis if needed
build-context-clauses Ctx Clauses :-
  std.map {coq.env.section} (x\r\ sigma F\ coq.env.typeof (const x) F, r = (decl (global (const x)) _ F)) SectionCtx,
  std.append Ctx SectionCtx CtxAndSection,
  ctx->clause {rewrite-dep CtxAndSection} Clauses. 

pred solve1 i:goal, i:list term, o:(list sealed-goal).
% solve1 (goal C _ (prod N Ty F) S _ as _G) _L GL :- !,
%   @pi-decl  N Ty x\
%     declare-evar [decl x N Ty|C] (Raw x) (F x) (Sol x),
%     solve1 (goal [decl x N Ty|C] (Raw x) (F x) (Sol x) []) _L GL,
%     if (Sol x = app [HD, x]) (S = HD) (S = fun N Ty Sol).
solve1 (goal _ _ (prod N _ _) _ _ as G) _L GL :- !,
  refine (fun N _ _) G GL1,
  coq.ltac.all (coq.ltac.open solve) GL1 GL.
solve1 (goal Ctx _ Ty Sol _ as G) _L GL :-
  var Sol,
  build-context-clauses Ctx Clauses,
  Ty = app [global TC | _],
  @redflags! coq.redflags.beta => coq.reduction.lazy.norm Ty Ty1,
  Clauses => if (tc-search-time TC Ty1 X) 
    (
      % @no-tc! => coq.elaborate-skeleton X _ X' ok,
      % coq.say "Solution " X "end" X' "caio",
      % std.assert! (ground_term X') "solution not complete",
      % (pi F\ (copy (fun _ _ x\ (app [F, x])) F :- !)) => copy X X',
      my-refine X G GL; 
      coq.say "illtyped solution:" {coq.term->string X}
    ) 
    (GL = [seal G]).

% In order to have more or less verbosity, 
% we use the solve1 predicate to make TC resolution.
% The solve predicate is used to have different Debug behaviors.
:if "solve-print-goal"
solve (goal Ctx _ Ty _ _) _ :-
  coq.say "Ctx" Ctx "Ty" Ty, fail.
:if "solve-print-type"
solve (goal _ _ Ty _ _) _ :-
  coq.say "Ty" Ty, fail.
:if "solve-trace-time"
solve A B :- !,
  std.spy-do! [std.time (solve1 A [] B) Time, coq.say Time].
:if "solve-trace"
solve A B :- !,
  std.spy-do! [solve1 A [] B].
:if "solve-time"
solve A B :- !,
  std.time (solve1 A [] B) Time, coq.say "Time Solve" Time.
solve A B :- solve1 A [] B.
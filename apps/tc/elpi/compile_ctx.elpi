pred find i:list A, i:(A -> prop), o:option A.
find [] _ none.
find [H|_] F (some H) :- F H.
find [_|T] F Res :- find T F Res.

pred find-def i:term, i:goal-ctx, o:prop.
find-def G Ctx Res :-
  find Ctx (x\ x = def G _ _ _) (some Res).

% pred replace-type i:term, i:prop, o:term.
% replace-type (app L) (decl T _ (global (indt A)) as Decl) (app Res) :-
%   std.map L (x\r\ 
%     if2 (x = T) (r = global (indt A))
%         (app _ = x; fun _ _ _ = x) (replace-type x Decl r)
%         (r = x)
%   ) Res.
% replace-type (fun A B X) S (fun A B Res) :-
%   pi x\ replace-type (X x) S (Res x).
% replace-type A B A.

% if the term is a var, we seek in the context 
% its definition and return it.
% if the term is an application we return it
pred replace-vars i:term, i:goal-ctx, o:term.
replace-vars (sort _) _ _ :- !, fail.
replace-vars (app A) _ (app A).
replace-vars V Ctx Res :- 
  find-def V Ctx (def _ _ _ Res1),
  replace-vars Res1 Ctx Res.

pred debug-ctx->clause i:list prop.
:if "debug ctx->clause"
debug-ctx->clause LP :-
  coq.say "The clauses built from the context are:" LP, fail.
debug-ctx->clause _.

pred ctx->clause i:goal-ctx, i:term, o:pair term (list prop).
ctx->clause Ctx Type (pr Type Clauses) :-
  std.map-filter Ctx (x\r\ sigma Ty S R\ 
    (decl Ty _ S = x), 
    replace-vars S Ctx R,
    r = tc R Ty) 
    Clauses,
    debug-ctx->clause Clauses
  % std.fold Ctx Type (x\acc\res\ replace-type acc x res) TTTT
  .
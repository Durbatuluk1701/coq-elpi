pred add-modes-list i:gref, i:list term, i:term, i:list (list hint-mode), i:list (list term), o:prop.
add-modes-list T V (prod _ _ X) HintModes L (pi x\ C x):-
  std.map HintModes (x\r\ [r|_] = x) FST,
  std.map HintModes (x\r\ [_|r] = x) LAST,
  pi x\ sigma NewL\
    std.map2 L FST (l\m\r\ if (m = mode-input) (r = [x | l]) (r = l)) NewL,
    add-modes-list T [x | V] (X x) LAST NewL (C x).
add-modes-list T V _ _ L NewTc :-
  App = {coq.mk-app (global T) {std.rev V}},
  NewTc = (pi t s\ tc  T t App s :- std.forall L (x\ std.exists x var), !, coq.error "Invalid mode for" App).

% takes the type of a class and build a list
% of hint mode where the last element is mandatory
pred make-last-hint-mode-input i:term, o:list hint-mode.
make-last-hint-mode-input (prod _ _ (x\ (prod _ _ _) as T)) [mode-output | L] :-
  pi x\ make-last-hint-mode-input (T x) L. 
make-last-hint-mode-input (prod _ _ _) [mode-input].

% build a list of the seme langht as the the passed one
% where all the elements are []
pred build-empty-list i:list B, o:list (list A).
build-empty-list [] [].
build-empty-list [_ | TL] [[] | L] :- 
  build-empty-list TL L.

% add the hint modes of a Class to the database.
% note that if the Class has not specified hint mode
% then we assume the hint mode to be - - - ... !
pred add-modes i:gref.
add-modes GR :-
  % the hint mode is added only if not already added
  if (not (type-classes GR)) (
    coq.env.typeof GR Ty,
    coq.hints.modes GR "typeclass_instances" ModesProv,
    if (ModesProv = []) (Modes = [{make-last-hint-mode-input Ty}]) (Modes = ModesProv),
    add-modes-list GR [] Ty Modes {build-empty-list Modes} R,
    add-tc-db (before "hintHook") R,
    add-tc-db _ (type-classes GR)
  ) true.

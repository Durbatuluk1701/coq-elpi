pred add-modes-list i:term, i:list term, i:term, i:list (list hint-mode), i:list (list term), o:prop.
add-modes-list T V (prod _ _ X) HintModes L (pi x\ C x):-
  std.map HintModes (x\r\ [r|_] = x) FST,
  std.map HintModes (x\r\ [_|r] = x) LAST,
  pi x\ sigma NewL\
    std.map2 L FST (l\m\r\ if (m = mode-input) (r = [x | l]) (r = l)) NewL,
    add-modes-list T [x | V] (X x) LAST NewL (C x).
add-modes-list T V _ _ L NewTc :-
  App = {coq.mk-app T {std.rev V}},
  NewTc = (pi s\ tc App s :- std.forall L (x\ std.exists x var), !, coq.error "Invalid mode for" App).

% takes the type of a class and build a list
% of hint mode where the last element is mandatory
pred make-last-hint-mode-input i:term, o:list hint-mode.
make-last-hint-mode-input (prod _ _ (x\ (prod _ _ _) as T)) [mode-output | L] :-
  pi x\ make-last-hint-mode-input (T x) L. 
make-last-hint-mode-input (prod _ _ _) [mode-input].

% build a list of the seme langht as the the passed one
% where all the elements are []
pred build-empty-list i:list B, o:list (list A).
build-empty-list [] [].
build-empty-list [_ | TL] [[] | L] :- 
  build-empty-list TL L.

% add the hint modes of a Class to the database.
% note that if the Class has not specified hint mode
% then we assume the hint mode to be - - - ... !
pred add-modes i:string.
add-modes ClassName :-
  coq.locate ClassName GR,
  coq.env.typeof GR Ty,
  XX = global GR,
  coq.hints.modes GR "typeclass_instances" ModesProv,
  if (ModesProv = []) true (
  if (ModesProv = []) (Modes = [{make-last-hint-mode-input Ty}]) (Modes = ModesProv),
  % Modes = ModesProv,
  add-modes-list XX [] Ty Modes {build-empty-list Modes} R,
  coq.elpi.accumulate _ "tc.db" (clause _ (before "hintHook") R)).

% HO unif heuristic: F X = f a b ~> F = f a, X = b
pred unify-FO o:list term, i:int, o:term, o:list term.
unify-FO L ArgsNo Head Args :- var Head, not(var L), std.do! [
  std.length L Len,
  PrefixNo is Len - ArgsNo,
  PrefixNo > 0,
  std.split-at PrefixNo L [HD|Extra] Args,
  coq.mk-app HD Extra Head,
].
unify-FO L _ Head Args :- var L, not(var Head), not(var Args), std.do! [
  coq.mk-app Head Args (app L)
].
unify-FO L _ H A :- coq.error "unif-FO mess" L H A.

:index (1)
pred is-coq-term i:A.
is-coq-term (sort _).
is-coq-term (global _).
is-coq-term (pglobal _ _).
is-coq-term (app _).
is-coq-term (fun _ _ _).
is-coq-term (prod _ _ _ ). 
is-coq-term (fix _ _ _ _ ). 
is-coq-term (match _ _ _). 
is-coq-term (let _ _ _ _).
is-coq-term (primitive _).

pred locally-bound i:term.

pred build-fun i:term, i:A, o:term.
build-fun (prod N T Bo) V (fun N T Bo1) :- 
  is-coq-term V, !,
  pi x\ build-fun (Bo x) {coq.mk-app V [x]} (Bo1 x).
build-fun (prod N T Bo) V (fun N T Bo1) :- !,
  pi x\ build-fun (Bo x) (V x) (Bo1 x).
build-fun _ V V.

pred coq.reduction.eta-expand i:int, i:term, i:list term, o:A.
coq.reduction.eta-expand 0 P L X :- std.rev L L1, hd-beta P L1 Hd Args, coq.mk-app Hd Args X.
coq.reduction.eta-expand N P Acc (x\ Q x) :- N > 0, M is N - 1,
  pi x\ coq.reduction.eta-expand M P [x|Acc] (Q x).

pred ho-link o:term, i:term, o:A.
:name "ho-link"
ho-link C Ty E :- var E, not (var C), !, 
  coq.count-prods Ty N, coq.reduction.eta-expand N C [] E.
ho-link C Ty E :- var C, not (var E), !, 
  build-fun Ty E ETA, coq.reduction.eta-contract ETA C.
ho-link C Ty E :- not (var C), not (var E), !, same-eta C Ty [] E.
ho-link C Ty E :- build-fun Ty E C', C' = C.

pred same-eta i:term, i:term, i:list term, i:A.
:name "same-eta1"
same-eta C (prod _ _ F) V E :- !, pi x\ same-eta C (F x) [x|V] (E x).
:name "same-eta2"
same-eta C _ VarsRev E :-
  coq.mk-app C {std.rev VarsRev} CVars,
  hd-beta E [] Hd Args, coq.mk-app Hd Args EVars,
  std.assert! (same_term CVars EVars) "eta mess".

pred coq-intros i:list term, i:list term, i:list term, o:term, o:A.
coq-intros SC [] V K K :-
  std.append SC {std.rev V} L, prune K L.
coq-intros SC [HD|L] LL (fun `elpi_intro` Ty Bo) E :-
  coq.typecheck HD Ty ok,
  pi x\ coq-intros SC L [x | LL] (Bo x) (E x).

pred subst-ho i:term, i:A, o:term, o:A.
% pattern fragment 
subst-ho (app [ho-var X Pos|XS]) A YXS A1 :- 
  name X, ho-twin X Pos Y _ Ty, distinct_names XS, std.forall XS locally-bound, !,
  name YXS Y XS,
  std.unsafe-cast Y Y1,
  A1 = [ho-link X Ty Y1|A].
subst-ho X A X A :- var X, !.
subst-ho (app [X|XArgs]) A R A1 :- std.do![
  var X _ XScope,
  std.append XScope XArgs Scope,
  distinct_names Scope, !,
  coq-intros XScope XArgs [] X' E,
  hd-beta X' XArgs Aaa Baa,
  coq.mk-app Aaa Baa R,
  coq.typecheck X Ty ok,
  A1 = [ ho-link X Ty E | A]].
subst-ho (ho-var X Pos) A X A1 :- name X, ho-twin X Pos Y _ Ty, !, A1 = [ho-link X Ty Y|A].
% FO heuristic
subst-ho (app [ho-var X Pos|XS]) A (app L) A2 :- name X, ho-twin X Pos Y L Ty, !,
  std.length XS NARGS,
  std.fold-map XS A fold-map YS A1,
  A2 = [ho-link X Ty Y,unify-FO L NARGS X YS|A1].
% mark local binders
subst-ho (prod N T F) A (prod N T1 F1) A2 :- !,
  fold-map T A T1 A1, (pi x\ locally-bound x => fold-map (F x) A1 (F1 x) A2).
subst-ho (fun N T F) A (fun N T1 F1) A2 :- !,
  fold-map T A T1 A1, (pi x\ locally-bound x => fold-map (F x) A1 (F1 x) A2).
% subst-ho (ho-var A -1) X A X :- !.

pred ho-preprocess i:term, o:term, o:list prop.
ho-preprocess Ty TyX HOPremises :-
  (pi A B C D\ fold-map A B C D :- subst-ho A B C D) => 
  (pi A B X\ fold-map A B X B :- A = ho-var X _, !) =>
    fold-map Ty [] TyX HOPremisesRev,
  if-true true (
    coq.say "Preprocessing" Ty,
    coq.say "With TyX" TyX,
    coq.say "And Premises" HOPremisesRev
  ),
  std.rev HOPremisesRev HOPremises.

pred ho-cleanup i:term, o:term.
% ho-cleanup X X.
 ho-cleanup T T1 :- (pi X\ copy (ho-var X _) X) => copy T T1.

% [ho-twin Coq ElpiHO ElpiFO CoqVarTy]
% app[Coq|Args] -> (app ElpiFO)    / unif-FO ElpiFO N Coq Args
% app[Coq|Args] -> (ElpiHO Args)   / ho-link Coq CoqVarTy ElpiHO
pred ho-twin i:term, o:int, o:A, o:list term, o:term.
ho-twin X I_ Y_ Z_ Ty :- var X, !, 
  coq.typecheck X Ty ok.

type ho-var term -> int -> term.

pred count-occurrences i:term, i:term, o:term, o:int.
count-occurrences T V T1 N :-
  (pi A A1\ fold-map V A (ho-var V A) A1 :- !, A1 is A + 1) =>
  (pi A B\ fold-map A B A B :- A = ho-var _ _, !) =>
  fold-map T 0 T1 N, !.
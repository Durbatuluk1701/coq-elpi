% HO unif heuristic: F X = f a b ~> F = f a, X = b
pred unify-FO i:list term, i:int, o:term, o:list term.
unify-FO L ArgsNo Head Args :- std.do! [
  std.length L Len,
  PrefixNo is Len - ArgsNo,
  PrefixNo > 0,
  std.split-at PrefixNo L [HD|Extra] Args,
  coq.mk-app HD Extra Head,
].

pred locally-bound i:term.

pred build-fun i:term, i:A, o:term.
build-fun (prod N T Bo) V (fun N T (Bo1)) :- !,
  pi x\ build-fun (Bo x) (V x) (Bo1 x).
build-fun _ V V.

pred coq.reduction.eta-expand i:int, i:term, i:list term, o:A.
coq.reduction.eta-expand 0 P L X :- std.rev L L1, hd-beta P L1 Hd Args, coq.mk-app Hd Args X.
coq.reduction.eta-expand N P Acc (x\ Q x) :- N > 0, M is N - 1,
  pi x\ coq.reduction.eta-expand M P [x|Acc] (Q x).

pred ho-link o:term, i:term, o:A.
ho-link C Ty E :- var E, not (var C), !, coq.count-prods Ty N, coq.reduction.eta-expand N C [] E.
ho-link C Ty E :- var C, not (var E), !, build-fun Ty E ETA, coq.reduction.eta-contract ETA C.
ho-link C Ty E :- not (var C), not (var E), !, same-eta C Ty [] E.
ho-link O I A :- coq.error "ho-link:" O I A.

pred same-eta i:term, i:term, i:list term, i:A.
same-eta C (prod _ _ F) V E :- pi x\ same-eta C (F x) [x|V] (E x).
same-eta C _ VarsRev E :-
  coq.mk-app C {std.rev VarsRev} CVars,
  hd-beta E [] Hd Args, coq.mk-app Hd Args EVars,
  std.assert! (same_term CVars EVars) "eta mess".

pred subst-ho i:term, i:A, o:term, o:A.
% pattern fragment 
subst-ho (app [X|XS]) A YXS A1 :- ho-twin X Y _ Ty, distinct_names XS, std.forall XS locally-bound, !,
  name YXS Y XS,
  std.unsafe-cast Y Y1,
  %build-fun Ty Y1 Fun,
  A1 = [ho-link X Ty Y1|A].
subst-ho X A X A1 :- ho-twin X Y _ Ty, !, A1 = [ho-link X Ty Y|A].
% FO heuristic
subst-ho (app [X|XS]) A (app L) A2 :- ho-twin X Y L Ty, !,
  std.length XS NARGS,
  std.fold-map XS A fold-map YS A1,
  A2 = [ho-link X Ty Y,unify-FO L NARGS X YS|A1].
% mark local binders
subst-ho (prod N T F) A (prod N T1 F1) A2 :- !,
  fold-map T A T1 A1, (pi x\ locally-bound x => fold-map (F x) A1 (F1 x) A2).
subst-ho (fun N T F) A (fun N T1 F1) A2 :- !,
  fold-map T A T1 A1, (pi x\ locally-bound x => fold-map (F x) A1 (F1 x) A2).

% [ho-twin Coq ElpiHO ElpiFO CoqVarTy]
% app[Coq|Args] -> (app ElpiFO)    / unif-FO ElpiFO N Coq Args
% app[Coq|Args] -> (ElpiHO Args)   / ho-link Coq CoqVarTy ElpiHO
pred ho-twin i:term, o:A, o:list term, o:term.

<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Tutorial on Coq tactics</title>
<meta name="author" content="Enrico Tassi" />
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.13.0+0.13.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="tutorial-on-coq-tactics">
<h1 class="title">Tutorial on Coq tactics</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Enrico Tassi</td></tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<script>
var style = document.createElement('style');
style.textContent = `
  .alectryon-io {
     border-left-style: solid;
     border-left-color: lightgrey;
     padding-left: 1em;
     margin-left: 1em;
  }
  code.coq , code.elpi {
     border-style: solid;
     border-color: lightgrey;
     border-width: 0.1em;
     padding: 0.2em 0.3em 0.2em 0.3em;
     border-radius: 0.5em
  }
  body {
    line-height: 2;
  }
  div.warning , div.important, div.note, div.tip {
     border-style: solid;
     border-color: lightgrey;
     border-width: 0.1em;
     border-radius: 0.5em
  }
  .ghref {
    cursor: help;
    text-decoration: underline dotted;
    font-family: 'Iosevka Slab Web', 'Iosevka Web', 'Iosevka Slab', 'Iosevka', 'Fira Code', monospace;
    font-feature-settings: "XV00" 1; /* Use Coq ligatures when Iosevka is available */
    line-height: initial;
  }

  .elpi {
    font-family: 'Iosevka Slab Web', 'Iosevka Web', 'Iosevka Slab', 'Iosevka', 'Fira Code', monospace;
    font-feature-settings: "XV00" 1; /* Use Coq ligatures when Iosevka is available */
   }

  .highlight .-ElpiFunction , .highlight .n-ElpiFunction { color: #795E26 }
  .highlight .-ElpiVariable , .highlight .n-ElpiVariable { color: #0000ff }
  .highlight .k-ElpiKeyword { color: #AF00DB }
  .highlight .k-ElpiMode { color: #811f3f }
  .highlight .m-ElpiInteger { color: #098658 }

  .elpi .n-ElpiFunction { color: #795E26 }
  .elpi .n-ElpiVariable { color: #0000ff }
  .elpi .k-ElpiKeyword { color: #AF00DB }
  .elpi .k-ElpiMode { color: #811f3f }
  .elpi .m-ElpiInteger { color: #098658 }
  .elpi .s2 { color: #a31515 }

`;
document.getElementsByTagName('head')[0].appendChild(style);

</script><!-- Elpi is an extension language that comes as a library
to be embedded into host applications such as Coq.

Elpi is a variant of ŒªProlog enriched with constraints.
ŒªProlog is a programming language designed to make it easy
to manipulate abstract syntax trees containing binders.
Elpi extends ŒªProlog with programming constructs that are
designed to make it easy to manipulate abstract syntax trees
containing metavariables (also called unification variables, or
evars in the Coq jargon).

This software, "coq-elpi", is a Coq plugin embedding Elpi and
exposing to the extension language Coq spefic data types (e.g. terms)
and API (e.g. to declare a new inductive type).

In order to get proper syntax highlighting using VSCode please install the
"gares.coq-elpi-lang" extension. In CoqIDE please chose "coq-elpi" in
Edit -> Preferences -> Colors. -->
<p>This tutorial focuses on the implementation of Coq tactics.</p>
<p>This tutorial assumes the reader is familiar with Elpi and the HOAS
representation of Coq terms; if it is not the case, please take a look at
these other tutorials first:
<a class="reference external" href="https://lpcic.github.io/coq-elpi/tutorial_elpi_lang.html">Elpi tutorial</a>
and <a class="reference external" href="https://lpcic.github.io/coq-elpi/tutorial_coq_elpi_HOAS.html">Coq HOAS tutorial</a>.</p>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#defining-tactics" id="id2">Defining tactics</a></li>
<li><a class="reference internal" href="#arguments-and-tactic-notation" id="id3">Arguments and Tactic Notation</a></li>
<li><a class="reference internal" href="#examples-assumption-and-set" id="id4">Examples: <code class="highlight coq"><span class="bp">assumption</span></code> and <code class="highlight coq"><span class="nb">set</span></code></a></li>
<li><a class="reference internal" href="#id1" id="id5">The proof engine</a></li>
<li><a class="reference internal" href="#msolve-and-tactic-composition" id="id6">msolve and tactic composition</a></li>
<li><a class="reference internal" href="#tactic-in-terms" id="id7">Tactic in terms</a></li>
</ul>
</div>
<div class="section" id="defining-tactics">
<h1><a class="toc-backref" href="#id2">Defining tactics</a></h1>
<p>In Coq a proof is just a term, and an incomplete proof is just a term
with holes standing for the open goals.</p>
<p>When a proof starts there is just one hole (one goal) and its type
is the statement one wants to prove. Then proof construction makes
progress by instantiation: a term possibly containing holes is
grafted to the hole corresponding to the current goal. What a tactic
does behind the scenes is to synthesize this partial term.</p>
<p>Let's define a simple tactic that prints the current goal.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> <span class="nb">elpi</span> <span class="kn">Require Import</span> <span class="nb">elpi</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> show.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> lp:{{

  solve (goal <span class=" -ElpiVariable">Ctx</span> <span class=" -ElpiVariable">_Trigger</span> <span class=" -ElpiVariable">Type</span> <span class=" -ElpiVariable">Proof</span> <span class=" -ElpiVariable">_</span>) <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">:-</span>
    coq.say <span class="s2">&quot;Goal:&quot;</span> <span class=" -ElpiVariable">Ctx</span> <span class="s2">&quot;|-&quot;</span> <span class=" -ElpiVariable">Proof</span> <span class="s2">&quot;:&quot;</span> <span class=" -ElpiVariable">Type</span>.

}}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Typecheck</span>.</span></span></pre><p>The tactic declaration is made of 3 parts.</p>
<p>The first one <code class="highlight coq"><span class="n">Elpi</span> <span class="n">Tactic</span> <span class="n">show</span><span class="o">.</span></code> sets the current program to <code class="highlight coq"><span class="n">show</span></code>.
Since it is declared as a <code class="highlight coq"><span class="n">Tactic</span></code> some code is loaded automatically:</p>
<ul class="simple">
<li>APIs (eg <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/coq-builtin.elpi#L471">coq.say</a>) and data types (eg Coq terms) are loaded from
<a class="reference external" href="https://github.com/LPCIC/coq-elpi/blob/master/coq-builtin.elpi">coq-builtin.elpi</a></li>
<li>some utilities, like <a class="lib ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/elpi/coq-lib.elpi#L105">copy</a> or <a class="libred ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/elpi/elpi-reduction.elpi#L15">whd1</a> are loaded from
<a class="reference external" href="https://github.com/LPCIC/coq-elpi/blob/master/elpi/elpi-tactic-template.elpi">elpi-command-template.elpi</a></li>
</ul>
<p>The second one <code class="highlight coq"><span class="n">Elpi</span> <span class="n">Accumulate</span> <span class="o">...</span></code> loads some extra code.
The <code class="highlight coq"><span class="n">Elpi</span> <span class="n">Accumulate</span> <span class="o">...</span></code> family of commands lets one accumulate code
taken from:</p>
<ul class="simple">
<li>verbatim text <code class="highlight coq"><span class="n">Elpi</span> <span class="n">Accumulate</span> lp:{{ <span class="k-ElpiKeyword">&lt;</span>code&gt; }}</code></li>
<li>source files <code class="highlight coq"><span class="n">Elpi</span> <span class="n">Accumulate</span> <span class="n">File</span> <span class="o">&lt;</span><span class="n">path</span><span class="o">&gt;</span></code></li>
<li>data bases (Db) <code class="highlight coq"><span class="n">Elpi</span> <span class="n">Accumulate</span> <span class="n">Db</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span></code></li>
</ul>
<p>Accumulating code via inline text or file is equivalent, the AST of &lt;code&gt;
is stored in the .vo file (the external file does not need to be installed).
We invite the reader to look up the description of data bases in the tutorial
about commands.</p>
<p>Once all the code is accumulated <code class="highlight coq"><span class="n">Elpi</span> <span class="n">Typecheck</span></code> verifies that the
code does not contain the most frequent kind of mistakes. This command
considers some mistakes minor and only warns about them. You can
pass <code class="highlight coq"><span class="o">-</span><span class="n">w</span> <span class="o">+</span><span class="n">elpi</span><span class="o">.</span><span class="n">typecheck</span></code> to <code class="highlight coq"><span class="n">coqc</span></code> to turn these warnings into errors.</p>
<p>The entry point for tactics is called <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/coq-builtin.elpi#L46">solve</a> which maps a <a class="type ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/coq-builtin.elpi#L252">goal</a>
into a list of <a class="type ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/coq-builtin.elpi#L253">sealed-goal</a> (representing subgoals).</p>
<p>Tactics written in Elpi can be invoked by prefixing its name with <code class="highlight coq"><span class="n">elpi</span></code>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk0"><span class="kn">Lemma</span> <span class="nf">tutorial</span> <span class="nv">x</span> <span class="nv">y</span>  : x + <span class="mi">1</span> = y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x + <span class="mi">1</span> = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk1"><span class="nb">elpi</span> show.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Goal</span>: 
[decl c1 `y` (<span class="kn">global</span> (indt ¬´nat¬ª)), decl c0 `x` (<span class="kn">global</span> (indt ¬´nat¬ª))] 
|- X0 c0 c1 : 
app
 [<span class="kn">global</span> (indt ¬´eq¬ª), <span class="kn">global</span> (indt ¬´nat¬ª), 
  app
   [<span class="kn">global</span> (const ¬´Nat.add¬ª), c0, 
    app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)]], c1]</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x + <span class="mi">1</span> = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span></span></pre><p>In the Elpi code up there <code class="highlight coq"><span class="kn">Proof</span></code> is the hole for the current goal,
<code class="highlight coq"><span class="kt">Type</span></code> the statement to be proved and <code class="highlight coq"><span class="n">Ctx</span></code> the proof context (the list of
hypotheses). Since we don't assign <code class="highlight coq"><span class="kn">Proof</span></code> the tactic makes no progess.
Elpi prints somethinglike this:</p>
<pre class="code literal-block">
Goal:
[decl&nbsp;c0&nbsp;`x`&nbsp;(global&nbsp;(indt&nbsp;¬´nat¬ª)),&nbsp;decl&nbsp;c1&nbsp;`y`&nbsp;(global&nbsp;(indt&nbsp;¬´nat¬ª))]&nbsp;
|-&nbsp;X0&nbsp;c0&nbsp;c1&nbsp;:&nbsp;
   app [global&nbsp;(indt&nbsp;¬´eq¬ª),&nbsp;global&nbsp;(indt&nbsp;¬´nat¬ª),&nbsp;
      &nbsp;&nbsp;app&nbsp;[global&nbsp;(const&nbsp;¬´Nat.add¬ª),
             c0,&nbsp;app&nbsp;[global&nbsp;(indc&nbsp;¬´S¬ª),&nbsp;global&nbsp;(indc&nbsp;¬´O¬ª)]],
        c1]
</pre>
<p>The first line is the proof context:
proof variables are bound Elpi variables (here <code class="highlight coq"><span class="n">c0</span></code> and <code class="highlight coq"><span class="n">c1</span></code>), the context is
a list of predicates holding on them (their type in Coq). For example:</p>
<pre class="code literal-block">
decl&nbsp;c0&nbsp;`x`&nbsp;(global&nbsp;(indt&nbsp;¬´nat¬ª))
</pre>
<p>asserts that <code class="highlight coq"><span class="n">c0</span></code> (pretty printed as <code class="highlight coq"><span class="n">x</span></code>) has type <code class="highlight coq"><span class="n">nat</span></code>.</p>
<p>Then we see that the value of <code class="highlight coq"><span class="kn">Proof</span></code> is <code class="highlight coq"><span class="n">X0</span> <span class="n">c0</span> <span class="n">c1</span></code>. This means that the
proof of the current goal is represented by Elpi's variable <code class="highlight coq"><span class="n">X0</span></code> and that
the variable has <code class="highlight coq"><span class="n">c0</span></code> and <code class="highlight coq"><span class="n">c1</span></code> in scope (the proof term can use them).</p>
<p>Finally we see the type of the goal <code class="highlight coq"><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">=</span> <span class="n">y</span></code>.</p>
<p>The <code class="highlight coq"><span class="n">_Trigger</span></code> component, which we did not print, is a variable that, when
assigned, trigger the elaboration of its value against the type of the goal
and obtains a value for <code class="highlight coq"><span class="kn">Proof</span></code> this way.</p>
<p>Keeping in mind that the <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/coq-builtin.elpi#L46">solve</a> predicate relates one goal to a list of
subgoals, we implement our first tactic which blindly tries to solve the goal.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> blind.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> lp:{{
  solve (goal <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">Trigger</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span>) <span class="k k-ElpiKeyword">[]</span> <span class="k k-ElpiKeyword">:-</span> <span class=" -ElpiVariable">Trigger</span> <span class="k k-ElpiKeyword">=</span> {{<span class="mi">0</span>}}.
  solve (goal <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">Trigger</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span>) <span class="k k-ElpiKeyword">[]</span> <span class="k k-ElpiKeyword">:-</span> <span class=" -ElpiVariable">Trigger</span> <span class="k k-ElpiKeyword">=</span> {{I}}.
}}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Typecheck</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk2"><span class="kn">Lemma</span> <span class="nf">test_blind</span> : <span class="kt">True</span> * nat.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kt">True</span> * nat)%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kt">True</span> * nat)%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk4"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">nat</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">elpi</span> blind.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">nat</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">elpi</span> blind.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk7"><span class="kn">Show Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">(I, <span class="mi">0</span>)</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Since the assignment of a term to <code class="highlight coq"><span class="n">Trigger</span></code> triggers its elaboration against
the expected type (the goal statement), assigning the wrong proof term
results in a failure which in turn results in the other clause being tried.</p>
<p>Assigning <code class="highlight coq"><span class="kn">Proof</span></code> directly is &quot;unsound&quot; in the sense that no automatic check
is performed.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> blind_bad.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> lp:{{
  solve (goal <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">Proof</span> <span class=" -ElpiVariable">_</span>) <span class="k k-ElpiKeyword">[]</span> <span class="k k-ElpiKeyword">:-</span> <span class=" -ElpiVariable">Proof</span> <span class="k k-ElpiKeyword">=</span> {{<span class="mi">0</span>}}.
  solve (goal <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">Proof</span> <span class=" -ElpiVariable">_</span>) <span class="k k-ElpiKeyword">[]</span> <span class="k k-ElpiKeyword">:-</span> <span class=" -ElpiVariable">Proof</span> <span class="k k-ElpiKeyword">=</span> {{I}}.
}}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Typecheck</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk8"><span class="kn">Lemma</span> <span class="nf">test_blind_bad</span> : <span class="kt">True</span> * nat.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kt">True</span> * nat)%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kt">True</span> * nat)%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chka"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">nat</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chkb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">elpi</span> blind_bad.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chkc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">nat</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">elpi</span> blind_bad.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chkd"><span class="kn">Show Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">(<span class="mi">0</span>, <span class="mi">0</span>)</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chke"><span class="kn">Fail</span> <span class="kn">Qed</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The command has indeed failed <span class="kr">with</span> message:
Illegal application: 
The term <span class="s2">&quot;@pair&quot;</span> of type
 <span class="s2">&quot;forall A B : Type, A -&gt; B -&gt; A * B&quot;</span>
cannot be applied to the terms
 <span class="s2">&quot;True&quot;</span> : <span class="s2">&quot;Prop&quot;</span>
 <span class="s2">&quot;nat&quot;</span> : <span class="s2">&quot;Set&quot;</span>
 <span class="s2">&quot;0&quot;</span> : <span class="s2">&quot;nat&quot;</span>
 <span class="s2">&quot;0&quot;</span> : <span class="s2">&quot;nat&quot;</span>
The <span class="mi">3</span>rd term has type <span class="s2">&quot;nat&quot;</span>
which should be coercible to <span class="s2">&quot;True&quot;</span>.</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span></span></pre><p>For now, this is all about the low level mechanics of tactics which is
developed further in the section <a class="reference internal" href="#the-proof-engine">The-proof-engine</a>.</p>
<p>We now focus on how to better integrate tactics written in Elpi with Ltac.</p>
<p>For a simple tactic like blind the list of subgoals is easy to write, since
it is empty, but in general one should collect all the holes in
the value of Proof (the checked proof term) and build goals out of them.</p>
<p>There is a family of APIs named after <a class="libtac ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/elpi/elpi-ltac.elpi#L8">refine</a>, the mother of all tactics, in
<a class="reference external" href="https://github.com/LPCIC/coq-elpi/blob/master/elpi/elpi-ltac.elpi">elpi-ltac.elpi</a>
which does this job for you.</p>
<p>Usually a tactic builds a (possibly partial) term and calls <a class="libtac ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/elpi/elpi-ltac.elpi#L8">refine</a> on it.</p>
<p>Let's rewrite the <code class="highlight coq"><span class="n">blind</span></code> tactic using this schema.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> blind2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> lp:{{
  solve <span class=" -ElpiVariable">G</span> <span class=" -ElpiVariable">GL</span> <span class="k k-ElpiKeyword">:-</span> refine {{<span class="mi">0</span>}} <span class=" -ElpiVariable">G</span> <span class=" -ElpiVariable">GL</span>.
  solve <span class=" -ElpiVariable">G</span> <span class=" -ElpiVariable">GL</span> <span class="k k-ElpiKeyword">:-</span> refine {{I}} <span class=" -ElpiVariable">G</span> <span class=" -ElpiVariable">GL</span>.
}}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Typecheck</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chkf"><span class="kn">Lemma</span> <span class="nf">test_blind2</span> : <span class="kt">True</span> * nat.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kt">True</span> * nat)%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk10"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kt">True</span> * nat)%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk11"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">nat</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk12">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">elpi</span> blind2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk13">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">nat</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">elpi</span> blind2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>This schema works even if the term is partial, that is if it contains holes
corresponding to missing sub proofs. Let's write a tactic which opens
a few subgoals, let's implement the <code class="highlight coq"><span class="nb">split</span></code> tactic.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">Elpi's equality (that is, unification) on Coq terms corresponds to
alpha equivalence, we can use that to make our tactic less blind.</p>
</div>
<p>The head of a clause for the solve predicate is matched against the
goal. This operation cannot assign unification variables in the goal, only
variables in the clause's head.
As a consequence the following clause for <code class="highlight coq"><span class="kp">solve</span></code> only triggers when
the statement features an explicit conjunction.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk14"><span class="kn">About</span> conj. <span class="c">(* conj : forall [A B : Prop], A -&gt; B -&gt; A /\ B *)</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">conj : <span class="kr">forall</span> [A B : <span class="kt">Prop</span>], A -&gt; B -&gt; A /\ B

conj <span class="kr">is</span> not universe polymorphic
<span class="kn">Arguments</span> conj [A B]%type_scope _ _
Expands to: Constructor Coq.Init.Logic.conj</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> <span class="nb">split</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> lp:{{
  solve (goal <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> {{ _ /\ _ }} <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">as</span> <span class=" -ElpiVariable">G</span>) <span class=" -ElpiVariable">GL</span> <span class="k k-ElpiKeyword">:-</span> <span class="k k-ElpiKeyword">!,</span>
    <span class="c">% conj has 4 arguments, but two are implicits</span>
    <span class="c">% (_ are added for them and are inferred from the goal)</span>
    refine {{ conj _ _ }} <span class=" -ElpiVariable">G</span> <span class=" -ElpiVariable">GL</span>.

  solve <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">:-</span>
    <span class="c">% This signals a failure in the Ltac model. A failure</span>
    <span class="c">% in Elpi, that is no more cluases to try, is a fatal</span>
    <span class="c">% error that cannot be catch by Ltac combinators like repeat.</span>
    coq.ltac.fail <span class=" -ElpiVariable">_</span> <span class="s2">&quot;not a conjunction&quot;</span>.
}}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Typecheck</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk15"><span class="kn">Lemma</span> <span class="nf">test_split</span> : <span class="kr">exists</span> <span class="nv">t</span> : <span class="kt">Prop</span>, <span class="kt">True</span> /\ <span class="kt">True</span> /\ t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t</span> : <span class="kt">Prop</span>, <span class="kt">True</span> /\ <span class="kt">True</span> /\ t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk16"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t</span> : <span class="kt">Prop</span>, <span class="kt">True</span> /\ <span class="kt">True</span> /\ t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk17"><span class="nb">eexists</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span> /\ <span class="kt">True</span> /\ <span class="nl">?t</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk18"><span class="kp">repeat</span> <span class="nb">elpi</span> <span class="nb">split</span>. <span class="c">(* The failure is catched by Ltac&#39;s repeat *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?t</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* Remark that the last goal is left untouched, since</span>
<span class="c">   it did not match the pattern {{ _ /\ _ }}. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">elpi</span> blind.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk19"><span class="kn">Show Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">(ex_intro (<span class="kr">fun</span> <span class="nv">t</span> : <span class="kt">Prop</span> =&gt; <span class="kt">True</span> /\ <span class="kt">True</span> /\ t) <span class="kt">True</span>
   (conj I (conj I I)))</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>The tactic <code class="highlight coq"><span class="nb">split</span></code> succeeds twice, stopping on the two identical goals <code class="highlight coq"><span class="kt">True</span></code> and
the one which is an evar of type <code class="highlight coq"><span class="kt">Prop</span></code>.</p>
<p>We then invoke <code class="highlight coq"><span class="n">blind</span></code> on all goals. In the third case the type checking
constraint triggered by assigning <code class="highlight coq"><span class="o">{{</span><span class="mi">0</span><span class="o">}}</span></code> to <code class="highlight coq"><span class="n">Trigger</span></code> fails because
its type <code class="highlight coq"><span class="n">nat</span></code> is not of sort <code class="highlight coq"><span class="kt">Prop</span></code>, so it backtracks and picks <code class="highlight coq"><span class="o">{{</span><span class="n">I</span><span class="o">}}</span></code>.</p>
<p>Another common way to build an Elpi tactic is to synthesize a term and
then call some Ltac piece of code finishing the work.</p>
<p>The API <a class="libtac ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/elpi/elpi-ltac.elpi#L31">coq.ltac.call</a> invokes some Ltac piece
of code passing to it the desired
arguments. Then it builds the list of subgoals.</p>
<p>Here we pass an integer, which in turn is passed to <code class="highlight coq"><span class="kp">fail</span></code>, and a term,
which is turn is passed to <code class="highlight coq"><span class="nb">apply</span></code>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">helper_split2</span> n t := <span class="kp">fail</span> n || <span class="nb">apply</span> t.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> split2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> lp:{{
  solve (goal <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> {{ _ /\ _ }} <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">as</span> <span class=" -ElpiVariable">G</span>) <span class=" -ElpiVariable">GL</span> <span class="k k-ElpiKeyword">:-</span>
    coq.ltac.call <span class="s2">&quot;helper_split2&quot;</span> <span class="k k-ElpiKeyword">[</span>int <span class="m m-ElpiInteger">0</span><span class="k k-ElpiKeyword">,</span> trm {{ conj }}<span class="k k-ElpiKeyword">]</span> <span class=" -ElpiVariable">G</span> <span class=" -ElpiVariable">GL</span>.
  solve <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">:-</span>
    coq.ltac.fail <span class=" -ElpiVariable">_</span> <span class="s2">&quot;not a conjunction&quot;</span>.
}}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Typecheck</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk1a"><span class="kn">Lemma</span> <span class="nf">test_split2</span> : <span class="kr">exists</span> <span class="nv">t</span> : <span class="kt">Prop</span>, <span class="kt">True</span> /\ <span class="kt">True</span> /\ t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t</span> : <span class="kt">Prop</span>, <span class="kt">True</span> /\ <span class="kt">True</span> /\ t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk1b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t</span> : <span class="kt">Prop</span>, <span class="kt">True</span> /\ <span class="kt">True</span> /\ t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk1c"><span class="nb">eexists</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span> /\ <span class="kt">True</span> /\ <span class="nl">?t</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk1d"><span class="kp">repeat</span> <span class="nb">elpi</span> split2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?t</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">elpi</span> blind.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></div>
<div class="section" id="arguments-and-tactic-notation">
<h1><a class="toc-backref" href="#id3">Arguments and Tactic Notation</a></h1>
<p>Elpi tactics can receive arguments. Arguments are received as a list, which
is the last argument of the goal constructor. This suggests that arguments
are attached to the current goal being observed, but we will dive into
this detail later on.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> print_args.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> lp:{{
  solve (goal <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">Args</span>) <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">:-</span> coq.say <span class=" -ElpiVariable">Args</span>.
}}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Typecheck</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk1e"><span class="kn">Lemma</span> <span class="nf">test_print_args</span> : <span class="kt">True</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk1f"><span class="nb">elpi</span> print_args <span class="mi">1</span> x <span class="s2">&quot;a b&quot;</span> (<span class="mi">1</span> = <span class="mi">0</span>).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[int <span class="mi">1</span>, str x, str a b, 
 trm
  (app
    [<span class="kn">global</span> (indt ¬´eq¬ª), X0, 
     app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)], <span class="kn">global</span> (indc ¬´O¬ª)])]</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span></span></pre><p>The convention is that numbers like <code class="highlight coq"><span class="mi">1</span></code> are passed a <code class="highlight coq"><span class="n">int</span> <span class="o">&lt;</span><span class="n">arg</span><span class="o">&gt;</span></code>,
identifiers or strings are passed as <code class="highlight coq"><span class="n">str</span> <span class="o">&lt;</span><span class="n">arg</span><span class="o">&gt;</span></code> and terms
have to be put between parentheses.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p>terms are received in raw format, eg before elaboration.</p>
<p class="last">Indeed the type argument to <code class="highlight coq"><span class="n">eq</span></code> is a variable.
One can use APIs like <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/coq-builtin.elpi#L1067">coq.elaborate-skeleton</a> to infer holes like <code class="highlight coq"><span class="n">X0</span></code>.</p>
</div>
<p>See the <a class="type ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/coq-builtin.elpi#L50">argument</a> data type
for a detailed decription of all the arguments a tactic can receive.</p>
<p>Now let's write a tactic which behave pretty much like the <a class="libtac ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/elpi/elpi-ltac.elpi#L8">refine</a> one
from Coq, but prints what it does using the API <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/coq-builtin.elpi#L1211">coq.term-&gt;string</a>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> <span class="nb">refine</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> lp:{{
  solve (goal <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">Ty</span> <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">[</span>trm <span class=" -ElpiVariable">S</span><span class="k k-ElpiKeyword">]</span> <span class="k k-ElpiKeyword">as</span> <span class=" -ElpiVariable">G</span>) <span class=" -ElpiVariable">GL</span> <span class="k k-ElpiKeyword">:-</span>
    <span class="c">% check S elaborates to T of type Ty (the goal)</span>
    coq.elaborate-skeleton <span class=" -ElpiVariable">S</span> <span class=" -ElpiVariable">Ty</span> <span class=" -ElpiVariable">T</span> ok<span class="k k-ElpiKeyword">,</span>

    coq.say <span class="s2">&quot;Using&quot;</span> {coq.term-&gt;string <span class=" -ElpiVariable">T</span>}
            <span class="s2">&quot;of type&quot;</span> {coq.term-&gt;string <span class=" -ElpiVariable">Ty</span>},

    <span class="c">% since T is already checked, we don&#39;t check it again</span>
    refine.no_check <span class=" -ElpiVariable">T</span> <span class=" -ElpiVariable">G</span> <span class=" -ElpiVariable">GL</span>.

  solve (goal <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">[</span>trm <span class=" -ElpiVariable">S</span><span class="k k-ElpiKeyword">]</span>) <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">:-</span>
    <span class=" -ElpiVariable">Msg</span> <span class="k k-ElpiKeyword">is</span> {coq.term-&gt;string <span class=" -ElpiVariable">S</span>} <span class="k k-ElpiKeyword">^</span> <span class="s2">&quot; does not fit&quot;</span><span class="k k-ElpiKeyword">,</span>
    coq.ltac.fail <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">Msg</span>.
}}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Typecheck</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk20"><span class="kn">Lemma</span> <span class="nf">test_refine</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">H</span> : P -&gt; Q) : Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P -&gt; Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk21"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P -&gt; Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk22"><span class="kn">Fail</span> <span class="nb">elpi</span> <span class="nb">refine</span> (H).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The command has indeed failed <span class="kr">with</span> message:
<span class="kn">Tactic</span> failure: H does not fit.</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P -&gt; Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk23"><span class="nb">elpi</span> <span class="nb">refine</span> (H _).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Using H <span class="nl">?p</span> of type Q</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P -&gt; Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span></span></pre><p>It is customary to use the Tactic Notation command to attach a nicer syntax
to Elpi tactics.</p>
<p>In particular elpi tacname accepts as arguments the following <a class="reference external" href="https://coq.inria.fr/doc/proof-engine/ltac.html#syntactic-values">bridges
for Ltac values</a> :</p>
<ul class="simple">
<li><code class="highlight coq"><span class="n">ltac_string</span><span class="o">:(</span><span class="n">v</span><span class="o">)</span></code> (for <code class="highlight coq"><span class="n">v</span></code> of type <code class="highlight coq"><span class="n">string</span></code> or <code class="highlight coq"><span class="kn">ident</span></code>)</li>
<li><code class="highlight coq"><span class="n">ltac_int</span><span class="o">:(</span><span class="n">v</span><span class="o">)</span></code> (for <code class="highlight coq"><span class="n">v</span></code> of type <code class="highlight coq"><span class="n">int</span></code> or <code class="highlight coq"><span class="n">integer</span></code>)</li>
<li><code class="highlight coq"><span class="n">ltac_term</span><span class="o">:(</span><span class="n">v</span><span class="o">)</span></code> (for <code class="highlight coq"><span class="n">v</span></code> of type <code class="highlight coq"><span class="kp">constr</span></code> or <code class="highlight coq"><span class="n">open_constr</span></code> or <code class="highlight coq"><span class="kp">uconstr</span></code> or <code class="highlight coq"><span class="n">hyp</span></code>)</li>
<li><code class="highlight coq"><span class="n">ltac_</span><span class="o">(</span><span class="n">string</span><span class="o">|</span><span class="n">int</span><span class="o">|</span><span class="n">term</span><span class="o">)</span><span class="n">_list</span><span class="o">:(</span><span class="n">v</span><span class="o">)</span></code> (for <code class="highlight coq"><span class="n">v</span></code> of type <code class="highlight coq"><span class="n">list</span></code> of ...)</li>
</ul>
<p>Note that the Ltac type associates some semantics to the action of passing
the arguments. For example <code class="highlight coq"><span class="n">hyp</span></code> will accept an identifier only if it is
an hypotheses of the context. While <code class="highlight coq"><span class="kp">uconstr</span></code> does not type check the term,
which is the recommended way to pass terms to an Elpi tactic (since it is
likely to be typed anyway by the Elpi tactic).</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;use&quot;</span> <span class="kp">uconstr</span>(t) :=
  <span class="nb">elpi</span> <span class="nb">refine</span> ltac_term:(t).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;use&quot;</span> hyp(t) :=
  <span class="nb">elpi</span> <span class="nb">refine</span> ltac_term:(t).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk24"><span class="kn">Lemma</span> <span class="nf">test_use</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">H</span> : P -&gt; Q) (<span class="nv">p</span> : P) : Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P -&gt; Q</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk25"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P -&gt; Q</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk26">use (H _).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Using H <span class="nl">?p</span> of type Q</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P -&gt; Q</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk27"><span class="kn">Fail</span> use q.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The command has indeed failed <span class="kr">with</span> message:
No such hypothesis: q</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P -&gt; Q</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk28">use p.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Using p of type P</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;print&quot;</span> uconstr_list_sep(l, <span class="s2">&quot;,&quot;</span>) :=
  <span class="nb">elpi</span> print_args ltac_term_list:(l).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk29"><span class="kn">Lemma</span> <span class="nf">test_print</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">H</span> : P -&gt; Q) (<span class="nv">p</span> : P) : Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P -&gt; Q</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk2a">print P, p, (H p).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[trm c0, trm c3, trm (app [c2, c3])]</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P -&gt; Q</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span></span></pre></div>
<div class="section" id="examples-assumption-and-set">
<h1><a class="toc-backref" href="#id4">Examples: <code class="highlight coq"><span class="bp">assumption</span></code> and <code class="highlight coq"><span class="nb">set</span></code></a></h1>
<p>A very simple tactic we can implement is <code class="highlight coq"><span class="bp">assumption</span></code>: we look up in the proof
context for an hypothesis which unifies with the goal.
Recall that <code class="highlight coq"><span class="n">Ctx</span></code> is made of <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/coq-builtin.elpi#L159">decl</a> and <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/coq-builtin.elpi#L160">def</a>
clauses (here, for simplicity, we
ignore the latter case).</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> lp:{{
  solve (goal <span class=" -ElpiVariable">Ctx</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">Ty</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">as</span> <span class=" -ElpiVariable">G</span>) <span class=" -ElpiVariable">GL</span> <span class="k k-ElpiKeyword">:-</span>
    <span class="c">% H is the name of hyp, Ty is the goal</span>
    std.mem <span class=" -ElpiVariable">Ctx</span> (decl <span class=" -ElpiVariable">H</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">Ty</span>)<span class="k k-ElpiKeyword">,</span>
    refine <span class=" -ElpiVariable">H</span> <span class=" -ElpiVariable">G</span> <span class=" -ElpiVariable">GL</span>.
  solve <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">:-</span>
    coq.ltac.fail <span class=" -ElpiVariable">_</span> <span class="s2">&quot;no such hypothesis&quot;</span>.
}}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Typecheck</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk2b"><span class="kn">Lemma</span> <span class="nf">test_assumption</span>  (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">p</span> : P) (<span class="nv">q</span> : Q) : P /\ id Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P /\ id Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk2c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P /\ id Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk2d"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk2e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><label class="goal-separator" for="tutorial-coq-elpi-tactic-v-chk2e"><hr></label><div class="goal-conclusion">id Q</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk2f"><span class="nb">elpi</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">id Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk30"><span class="kn">Fail</span> <span class="nb">elpi</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The command has indeed failed <span class="kr">with</span> message:
<span class="kn">Tactic</span> failure: no such hypothesis.</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">id Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span></span></pre><p>As we hinted before, Elpi's equality is alpha equivalence. In the second
goal the assumption has type <code class="highlight coq"><span class="n">Q</span></code> but the goal has type <code class="highlight coq"><span class="n">id</span> <span class="n">Q</span></code> which is
convertible (unifiable, for Coq's unification) to <code class="highlight coq"><span class="n">Q</span></code>.</p>
<p>Let's improve our tactic looking for an assumption which is unifiable with
the goal, an not just alpha convertible</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> assumption2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> lp:{{
  solve (goal <span class=" -ElpiVariable">Ctx</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">Ty</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">as</span> <span class=" -ElpiVariable">G</span>) <span class=" -ElpiVariable">GL</span> <span class="k k-ElpiKeyword">:-</span>
    <span class="c">% std.mem is backtracking (std.mem! would stop at the first hit)</span>
    std.mem <span class=" -ElpiVariable">Ctx</span> (decl <span class=" -ElpiVariable">H</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">Ty&#39;</span>)<span class="k k-ElpiKeyword">,</span> coq.unify-leq <span class=" -ElpiVariable">Ty&#39;</span> <span class=" -ElpiVariable">Ty</span> ok<span class="k k-ElpiKeyword">,</span>
    refine <span class=" -ElpiVariable">H</span> <span class=" -ElpiVariable">G</span> <span class=" -ElpiVariable">GL</span>.
  solve <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">:-</span>
    coq.ltac.fail <span class=" -ElpiVariable">_</span> <span class="s2">&quot;no such hypothesis&quot;</span>.
}}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Typecheck</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk31"><span class="kn">Lemma</span> <span class="nf">test_assumption2</span>  (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">p</span> : P) (<span class="nv">q</span> : Q) : P /\ id Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P /\ id Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk32"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P /\ id Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk33"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk34" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><label class="goal-separator" for="tutorial-coq-elpi-tactic-v-chk34"><hr></label><div class="goal-conclusion">id Q</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">elpi</span> assumption2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p><a class="libtac ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/elpi/elpi-ltac.elpi#L8">refine</a> does unify the type of goal with the type of the term, hence we can
just write the follwing code, which is very close to our initial <code class="highlight coq"><span class="n">blind</span></code>
tactic, but it picks candidates from the context.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> assumption3.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> lp:{{
  solve (goal <span class=" -ElpiVariable">Ctx</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">as</span> <span class=" -ElpiVariable">G</span>) <span class=" -ElpiVariable">GL</span> <span class="k k-ElpiKeyword">:-</span>
    std.mem <span class=" -ElpiVariable">Ctx</span> (decl <span class=" -ElpiVariable">H</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span>)<span class="k k-ElpiKeyword">,</span>
    refine <span class=" -ElpiVariable">H</span> <span class=" -ElpiVariable">G</span> <span class=" -ElpiVariable">GL</span>.
  solve <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">:-</span>
    coq.ltac.fail <span class=" -ElpiVariable">_</span> <span class="s2">&quot;no such hypothesis&quot;</span>.
}}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Typecheck</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk35"><span class="kn">Lemma</span> <span class="nf">test_assumption3</span>  (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">p</span> : P) (<span class="nv">q</span> : Q) : P /\ id Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P /\ id Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk36"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P /\ id Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk37"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk38" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><label class="goal-separator" for="tutorial-coq-elpi-tactic-v-chk38"><hr></label><div class="goal-conclusion">id Q</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">elpi</span> assumption3.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Now let's write a tactic which takes a term, possibly with holes, and
makes a let-in out of it, a bit like the <code class="highlight coq"><span class="nb">set</span></code> tactic.</p>
<p>It will be the occasion to explain the <a class="lib ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/elpi/coq-lib.elpi#L105">copy</a> utility.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> find.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> lp:{{

solve (goal <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">T</span> <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">[</span>trm <span class=" -ElpiVariable">X</span><span class="k k-ElpiKeyword">]</span>) <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">:-</span>
  <span class="k k-ElpiKeyword">pi</span> <span class=" -ElpiVariable">x</span>\
    copy <span class=" -ElpiVariable">X</span> x <span class="k k-ElpiKeyword">=&gt;</span> copy <span class=" -ElpiVariable">T</span> (<span class=" -ElpiVariable">Tabs</span> x)<span class="k k-ElpiKeyword">,</span>
    if (occurs x (<span class=" -ElpiVariable">Tabs</span> x))
       (coq.say <span class="s2">&quot;found&quot;</span> {coq.term-&gt;string <span class=" -ElpiVariable">X</span>})
       (coq.ltac.fail <span class=" -ElpiVariable">_</span> <span class="s2">&quot;not found&quot;</span>).
}}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Typecheck</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk39"><span class="kn">Lemma</span> <span class="nf">test_find</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) : P /\ P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P /\ P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk3a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P /\ P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk3b"><span class="nb">elpi</span> find (P).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">found P</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P /\ P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk3c"><span class="kn">Fail</span> <span class="nb">elpi</span> find (Q).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The command has indeed failed <span class="kr">with</span> message:
<span class="kn">Tactic</span> failure: not found.</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P /\ P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk3d"><span class="nb">elpi</span> find (P /\ _).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">found P /\ P</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P /\ P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span></span></pre><p>This first approximation only prints the term it found, or better the first
intance of the given term.</p>
<p>Now lets focus on <a class="lib ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/elpi/coq-lib.elpi#L105">copy</a>. An excerpt:</p>
<pre class="code literal-block">
copy X X :- name X.
copy (global _ as C) C.
copy (fun N T F) (fun N T1 F1).
  copy T T1, pi x\ copy (F x) (F1 x).
copy (app L) (app L1) :- !, std.map L copy L1.
</pre>
<p>Copy implements the identity: it builds, recursively, a copy of the first
term into the second argument. Unless one loads in the context a new clause,
which takes precedence over the identity ones. Here we load</p>
<pre class="code literal-block">
copy X x
</pre>
<p>which, at run time, looks like</p>
<pre class="code literal-block">
copy (app [global (indt ¬´andn¬ª), sort prop, sort prop, c0, X0 c0 c1]) c2
</pre>
<p>and that clause masks the one for <a class="constructor ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/coq-builtin.elpi#L85">app</a> when the sub-term being copied
matches <code class="highlight coq"><span class="o">(</span><span class="n">P</span> <span class="o">/\</span> <span class="n">_</span><span class="o">)</span></code>.</p>
<p>Now let's refine the tactic to build a let-in, and complain if the
desired name is already taken.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> <span class="nb">set</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> lp:{{

solve (goal <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">T</span> <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">[</span>str <span class=" -ElpiVariable">ID</span><span class="k k-ElpiKeyword">,</span> trm <span class=" -ElpiVariable">X</span><span class="k k-ElpiKeyword">]</span> <span class="k k-ElpiKeyword">as</span> <span class=" -ElpiVariable">G</span>) <span class=" -ElpiVariable">GL</span> <span class="k k-ElpiKeyword">:-</span>
  <span class="k k-ElpiKeyword">pi</span> <span class=" -ElpiVariable">x</span>\
    copy <span class=" -ElpiVariable">X</span> x <span class="k k-ElpiKeyword">=&gt;</span> copy <span class=" -ElpiVariable">T</span> (<span class=" -ElpiVariable">Tabs</span> x)<span class="k k-ElpiKeyword">,</span>
    if (occurs x (<span class=" -ElpiVariable">Tabs</span> x))
       (if (coq.ltac.id-free? <span class=" -ElpiVariable">ID</span> <span class=" -ElpiVariable">G</span>) true
           (coq.warn <span class=" -ElpiVariable">ID</span> <span class="s2">&quot;is already taken, Elpi will make a name up&quot;</span>)<span class="k k-ElpiKeyword">,</span>
        coq.id-&gt;name <span class=" -ElpiVariable">ID</span> <span class=" -ElpiVariable">Name</span><span class="k k-ElpiKeyword">,</span>
        <span class=" -ElpiVariable">Hole</span> x <span class="k k-ElpiKeyword">=</span> {{ _ : lp:{{ <span class=" -ElpiVariable">Tabs</span> x }} }}<span class="k k-ElpiKeyword">,</span> <span class="c">% a hole with a type</span>
        refine (<span class="k k-ElpiKeyword">let</span> <span class=" -ElpiVariable">Name</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">X</span> <span class=" -ElpiVariable">x\</span> <span class=" -ElpiVariable">Hole</span> x) <span class=" -ElpiVariable">G</span> <span class=" -ElpiVariable">GL</span>)
       (coq.ltac.fail <span class=" -ElpiVariable">_</span> <span class="s2">&quot;not found&quot;</span>).

}}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Typecheck</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk3e"><span class="kn">Lemma</span> <span class="nf">test_set</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) : P /\ P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P /\ P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk3f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P /\ P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk40"><span class="nb">elpi</span> <span class="nb">set</span> <span class="s2">&quot;x&quot;</span> (P).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>P</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x /\ x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk41"><span class="nb">unfold</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>P</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P /\ P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk42"><span class="kn">Fail</span> <span class="nb">elpi</span> <span class="nb">set</span> <span class="s2">&quot;x&quot;</span> (Q).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The command has indeed failed <span class="kr">with</span> message:
<span class="kn">Tactic</span> failure: not found.</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>P</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P /\ P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk43"><span class="nb">elpi</span> <span class="nb">set</span> <span class="s2">&quot;x&quot;</span> (P /\ _).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">x <span class="kr">is</span> already taken, <span class="kn">Elpi</span> will make a name up
[lib,<span class="nb">elpi</span>]</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>P</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span></span><br><span><var>elpi_ctx_entry_3_</var><span><span class="hyp-body"><b>:= </b><span>P /\ P</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">elpi_ctx_entry_3_</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span></span></pre><p>The new hole is annotated with a type. Here we use quotations to write
that term, but we could have used the commodity <a class="macro ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/coq-builtin.elpi#L118">&#64;cast</a> macro:</p>
<pre class="code literal-block">
&#64;cast (Hole x) (Tabs x)
</pre>
<p>which unfolds to</p>
<pre class="code literal-block">
let `cast` (Tabs x) (Hole x) y\y
</pre>
<p>which is how &quot;type casts&quot; are represented in the HOAS of terms.</p>
<p>For more examples of (basic) tactics written in Elpi see the
<a class="reference external" href="https://github.com/LPCIC/coq-elpi/tree/master/apps/eltac">eltac app</a>.</p>
</div>
<div class="section" id="id1">
<span id="the-proof-engine"></span><h1><a class="toc-backref" href="#id5">The proof engine</a></h1>
<p>In this section we dive into the details of the proof engine, that is
how goals are represented in Elpi and things are wired up behind the scenes.</p>
<p>Let's inspect the proof state a bit deeper:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> show_more.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> lp:{{

  solve (goal <span class=" -ElpiVariable">Ctx</span> <span class=" -ElpiVariable">_Trigger</span> <span class=" -ElpiVariable">Type</span> <span class=" -ElpiVariable">Proof</span> <span class=" -ElpiVariable">_</span>) <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">:-</span>
    coq.say <span class="s2">&quot;Goal:&quot;</span> <span class=" -ElpiVariable">Ctx</span> <span class="s2">&quot;|-&quot;</span> <span class=" -ElpiVariable">Proof</span> <span class="s2">&quot;:&quot;</span> <span class=" -ElpiVariable">Type</span><span class="k k-ElpiKeyword">,</span>
    coq.say <span class="s2">&quot;Proof state:&quot;</span><span class="k k-ElpiKeyword">,</span>
    coq.sigma.print.

}}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Typecheck</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk44"><span class="kn">Lemma</span> <span class="nf">test_show_more</span> <span class="nv">x</span> : x + <span class="mi">1</span> = <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x + <span class="mi">1</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk45"><span class="nb">elpi</span> show_more.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Goal</span>: [decl c0 `x` (<span class="kn">global</span> (indt ¬´nat¬ª))] |- X0 c0 : 
app
 [<span class="kn">global</span> (indt ¬´eq¬ª), <span class="kn">global</span> (indt ¬´nat¬ª), 
  app
   [<span class="kn">global</span> (const ¬´Nat.add¬ª), c0, 
    app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)]], <span class="kn">global</span> (indc ¬´O¬ª)]</blockquote><blockquote class="alectryon-message"><span class="kn">Proof</span> state:</blockquote><blockquote class="alectryon-message"> {c0} : decl c0 `x` (<span class="kn">global</span> (indt ¬´nat¬ª))
   ?- <span class="nb">evar</span> (X1 c0) 
       (app
         [<span class="kn">global</span> (indt ¬´eq¬ª), <span class="kn">global</span> (indt ¬´nat¬ª), 
          app
           [<span class="kn">global</span> (const ¬´Nat.add¬ª), c0, 
            app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)]], 
          <span class="kn">global</span> (indc ¬´O¬ª)]) (X0 c0)  /* suspended on X1, X0 */
EVARS:
 <span class="nl">?X56</span>==[x |- x + <span class="mi">1</span> = <span class="mi">0</span>] (goal <span class="nb">evar</span>) {<span class="nl">?Goal</span>}
 <span class="nl">?X55</span>==[ |- <span class="kr">forall</span> <span class="nv">x</span> : nat, x + <span class="mi">1</span> = <span class="mi">0</span> =&gt; <span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; <span class="nl">?Goal</span>] (goal <span class="nb">evar</span>)
 <span class="nl">?X54</span>==[x |- <span class="kt">Type</span> =&gt; nat] (parameter A of @eq)
 <span class="nl">?X53</span>==[ |- <span class="kt">Set</span> =&gt; nat] (<span class="kp">type of</span> x)

UNIVERSES:
ALGEBRAIC UNIVERSES:{tutorial_coq_elpi_tactic.<span class="mi">3</span>}
UNDEFINED UNIVERSES:tutorial_coq_elpi_tactic.<span class="mi">3</span> := <span class="kt">Set</span>
WEAK CONSTRAINTS:
SHELF:||
FUTURE GOALS STACK:||<span class="nl">?X54</span>
<span class="nl">?X53</span>

Coq-<span class="kn">Elpi</span> mapping:
RAW:
<span class="nl">?X56</span> &lt;-&gt; X1
ELAB:
<span class="nl">?X56</span> &lt;-&gt; X0
</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x + <span class="mi">1</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span></span></pre><p>In addition to the goal we print the Elpi and Coq proof state,
plus the link between them.
The proof engine is the collection of goals together with their types.</p>
<p>In the side of Elpi this state is represented by constraints for the &quot;evar&quot;
predicate.</p>
<p>One can recognize the set of bound variables <code class="highlight coq"><span class="o">{</span><span class="n">c0</span><span class="o">}</span></code>, the hypothetical
context of clauses about these variable (that also corresponds to the proof
context), and finally the suspended goal <code class="highlight coq"><span class="nb">evar</span> <span class="o">(</span><span class="n">X1</span> <span class="n">c0</span><span class="o">)</span> <span class="o">..</span> <span class="o">(</span><span class="n">X0</span> <span class="n">c0</span><span class="o">)</span></code>.</p>
<p>The set of constraints on <code class="highlight coq"><span class="nb">evar</span></code> represents the Coq data structure called
sigma (hence the name of the API to print it) that is used to
represent the proof state in Coq. It is printed just afterwards:</p>
<pre class="code literal-block">
EVARS:
 ?X56==[x |- x + 1 = 0] (goal evar) {?Goal}

Coq-Elpi mapping:
RAW:
?X56 &lt;-&gt; X1
ELAB:
?X56 &lt;-&gt; X0
</pre>
<p>Here <code class="highlight coq"><span class="nl">?X56</span></code> is a Coq evar linked with Elpi's <code class="highlight coq"><span class="n">X0</span></code> and <code class="highlight coq"><span class="n">X1</span></code>.
<code class="highlight coq"><span class="n">X1</span></code> represents the goal (the trigger) while <code class="highlight coq"><span class="n">X0</span></code> represent the proof.
The meaning of the <code class="highlight coq"><span class="nb">evar</span></code> Elpi predicate linking the two is that the term
assigned to the trigger <code class="highlight coq"><span class="n">X1</span></code> has to be elaborated to the final proof term <code class="highlight coq"><span class="n">X0</span></code>,
that should be a well typed term of type <code class="highlight coq"><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">0</span></code>.
This means that when an Elpi tactic assigns a value to <code class="highlight coq"><span class="n">X1</span></code> some procedure to
turn that value into <code class="highlight coq"><span class="n">X0</span></code> is triggered. That procedure is called elaboration and
it is currently implemented by calling the <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/coq-builtin.elpi#L1067">coq.elaborate-skeleton</a> API.</p>
<p>Given this set up, it is impossible to use a term of the wrong type as a
proof. Lets declare simle tactic that tries <code class="highlight coq"><span class="mi">0</span></code> and <code class="highlight coq"><span class="n">I</span></code> as proof terms for a
goal, without even looking at it.</p>
<p>The refine utility simply assigns the trigger and then calls the
<a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/coq-builtin.elpi#L1142">coq.ltac.collect-goals</a> API on the elaborated proof term to get the list
of sub goals</p>
<p>Let's rewrite the split tactic using only low level operations.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> split_ll.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> lp:{{
  solve (goal <span class=" -ElpiVariable">Ctx</span> <span class=" -ElpiVariable">Trigger</span> {{ lp:<span class=" -ElpiVariable">A</span> /\ lp:<span class=" -ElpiVariable">B</span> }} <span class=" -ElpiVariable">Proof</span> <span class="k k-ElpiKeyword">[]</span>) <span class=" -ElpiVariable">GL</span> <span class="k k-ElpiKeyword">:-</span> <span class="k k-ElpiKeyword">!,</span>
    <span class=" -ElpiVariable">Trigger</span> <span class="k k-ElpiKeyword">=</span> {{ conj _ _ }}<span class="k k-ElpiKeyword">,</span>
    <span class=" -ElpiVariable">Proof</span> <span class="k k-ElpiKeyword">=</span> {{ conj lp:<span class=" -ElpiVariable">Pa</span> lp:<span class=" -ElpiVariable">Pb</span> }}<span class="k k-ElpiKeyword">,</span>
    <span class=" -ElpiVariable">GL</span> <span class="k k-ElpiKeyword">=</span> <span class="k k-ElpiKeyword">[</span>seal <span class=" -ElpiVariable">G1</span><span class="k k-ElpiKeyword">,</span> seal <span class=" -ElpiVariable">G2</span><span class="k k-ElpiKeyword">],</span>
    <span class=" -ElpiVariable">G1</span> <span class="k k-ElpiKeyword">=</span> goal <span class=" -ElpiVariable">Ctx</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">A</span> <span class=" -ElpiVariable">Pa</span> <span class="k k-ElpiKeyword">[],</span>
    <span class=" -ElpiVariable">G2</span> <span class="k k-ElpiKeyword">=</span> goal <span class=" -ElpiVariable">Ctx</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">B</span> <span class=" -ElpiVariable">Pb</span> <span class="k k-ElpiKeyword">[]</span>.
  solve <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">:-</span>
    coq.ltac.fail <span class=" -ElpiVariable">_</span> <span class="s2">&quot;not a conjunction&quot;</span>.
}}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Typecheck</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk46"><span class="kn">Lemma</span> <span class="nf">test_split_ll</span> : <span class="kr">exists</span> <span class="nv">t</span> : <span class="kt">Prop</span>, <span class="kt">True</span> /\ <span class="kt">True</span> /\ t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t</span> : <span class="kt">Prop</span>, <span class="kt">True</span> /\ <span class="kt">True</span> /\ t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk47"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t</span> : <span class="kt">Prop</span>, <span class="kt">True</span> /\ <span class="kt">True</span> /\ t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk48"><span class="nb">eexists</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span> /\ <span class="kt">True</span> /\ <span class="nl">?t</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk49"><span class="kp">repeat</span> <span class="nb">elpi</span> split_ll.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?t</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">elpi</span> blind.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Crafting by hand the list of subgoal is not easy.
In particular here we did not set up the new trigger for <code class="highlight coq"><span class="n">Pa</span></code> and <code class="highlight coq"><span class="n">Pb</span></code>, nor
seal the goals appropriately.</p>
<p>The <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/coq-builtin.elpi#L1142">coq.ltac.collect-goals</a> API helps us doing this.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> split_ll_bis.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> lp:{{
  solve (goal <span class=" -ElpiVariable">Ctx</span> <span class=" -ElpiVariable">Trigger</span> {{ lp:<span class=" -ElpiVariable">A</span> /\ lp:<span class=" -ElpiVariable">B</span> }} <span class=" -ElpiVariable">Proof</span> <span class="k k-ElpiKeyword">[]</span>) <span class=" -ElpiVariable">GL</span> <span class="k k-ElpiKeyword">:-</span> <span class="k k-ElpiKeyword">!,</span>
    <span class="c">% this triggers the elaboration</span>
    <span class=" -ElpiVariable">Trigger</span> <span class="k k-ElpiKeyword">=</span> {{ conj _ _ }}<span class="k k-ElpiKeyword">,</span>                   
    <span class="c">% we only take main goals</span>
    coq.ltac.collect-goals <span class=" -ElpiVariable">Proof</span> <span class=" -ElpiVariable">GL</span> <span class=" -ElpiVariable">_ShelvedGL</span>.
  solve <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">:-</span>
    coq.ltac.fail <span class=" -ElpiVariable">_</span> <span class="s2">&quot;not a conjunction&quot;</span>.
}}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk4a"><span class="kn">Elpi</span> <span class="kn">Typecheck</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">B <span class="kr">is</span> linear: name it _B (discard) or B_ (<span class="kp">fresh</span> variable)
[<span class="nb">elpi</span>.typecheck,<span class="nb">elpi</span>]</blockquote><blockquote class="alectryon-message">A <span class="kr">is</span> linear: name it _A (discard) or A_ (<span class="kp">fresh</span> variable)
[<span class="nb">elpi</span>.typecheck,<span class="nb">elpi</span>]</blockquote><blockquote class="alectryon-message">Ctx <span class="kr">is</span> linear: name it _Ctx (discard) or Ctx_ (<span class="kp">fresh</span> variable)
[<span class="nb">elpi</span>.typecheck,<span class="nb">elpi</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk4b"><span class="kn">Lemma</span> <span class="nf">test_split_ll_bis</span> : <span class="kr">exists</span> <span class="nv">t</span> : <span class="kt">Prop</span>, <span class="kt">True</span> /\ <span class="kt">True</span> /\ t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t</span> : <span class="kt">Prop</span>, <span class="kt">True</span> /\ <span class="kt">True</span> /\ t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk4c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">t</span> : <span class="kt">Prop</span>, <span class="kt">True</span> /\ <span class="kt">True</span> /\ t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk4d"><span class="nb">eexists</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span> /\ <span class="kt">True</span> /\ <span class="nl">?t</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk4e"><span class="kp">repeat</span> <span class="nb">elpi</span> split_ll_bis.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?t</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">elpi</span> blind.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>At the light of that, <a class="libtac ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/elpi/elpi-ltac.elpi#L8">refine</a> is simply:</p>
<pre class="code literal-block">
refine T (goal _ RawEv _ Ev _) GS :-
  RawEv = T, coq.ltac.collect-goals Ev GS _.
</pre>
<p>Now that we know the low level plumbing, we can use <a class="libtac ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/elpi/elpi-ltac.elpi#L8">refine</a>. The only detail
we still have to explain is what exactly a <a class="type ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/coq-builtin.elpi#L253">sealed-goal</a> is. A sealed goal
wraps into a single object all the proof variable and the assumptions about
them, making this object easy (or better, sound) to pass around. More details
in the next section.</p>
</div>
<div class="section" id="msolve-and-tactic-composition">
<h1><a class="toc-backref" href="#id6">msolve and tactic composition</a></h1>
<p>Since Coq 8.4 tactics can see more than one goal (multi-goal tactics).
You can access this feature by using <code class="highlight coq"><span class="kp">all</span><span class="o">:</span> <span class="n">tactic</span></code>:</p>
<ul class="simple">
<li>if the tactic is a regular one, it will be used on each goal independently</li>
<li>if the tactic is a multi-goal one, it will receive all goals</li>
</ul>
<p>In Elpi you can implement a multi-goal tactic by providing a clause for
the <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/coq-builtin.elpi#L47">msolve</a> predicate. Since such tactic will need to manipulate multiple
goals, potentially living in different proof context, it receives a list
of <a class="type ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/coq-builtin.elpi#L253">sealed-goal</a>, a data type which seals a goal and its proof context.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> ngoals.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> lp:{{

  msolve <span class=" -ElpiVariable">GL</span> <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">:-</span>
    coq.say <span class="s2">&quot;#goals =&quot;</span> {std.length <span class=" -ElpiVariable">GL</span>},
    coq.say <span class=" -ElpiVariable">GL</span>.

}}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Typecheck</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk4f"><span class="kn">Lemma</span> <span class="nf">test_undup</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) : P /\ Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P /\ Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk50"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P /\ Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk51"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk52" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><label class="goal-separator" for="tutorial-coq-elpi-tactic-v-chk52"><hr></label><div class="goal-conclusion">Q</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk53"><span class="kp">all</span>: <span class="nb">elpi</span> ngoals.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">#goals = <span class="mi">2</span></blockquote><blockquote class="alectryon-message">[(nabla c0 \
   nabla c1 \
    seal
     (goal [decl c1 `Q` (sort prop), decl c0 `P` (sort prop)] (X0 c0 c1) c0 
       (X1 c0 c1) [])), 
 (nabla c0 \
   nabla c1 \
    seal
     (goal [decl c1 `Q` (sort prop), decl c0 `P` (sort prop)] (X2 c0 c1) c1 
       (X3 c0 c1) []))]</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk54" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><label class="goal-separator" for="tutorial-coq-elpi-tactic-v-chk54"><hr></label><div class="goal-conclusion">Q</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span></span></pre><p>This simple tactic prints the number of goals it receives, as well as
the list itself. We see something like:</p>
<pre class="code literal-block">
#goals = 2
[(nabla c0 \
   nabla c1 \
	   seal
     (goal [decl c1 `Q` (sort prop), decl c0 `P` (sort prop)] (X0 c0 c1) c0 
       (X1 c0 c1) [])), 
 (nabla c0 \
   nabla c1 \
    seal
     (goal [decl c1 `Q` (sort prop), decl c0 `P` (sort prop)] (X2 c0 c1) c1 
       (X3 c0 c1) []))]
</pre>
<p><a class="constructor ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/coq-builtin.elpi#L254">nabla</a> binds all proof variables, then <a class="constructor ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/coq-builtin.elpi#L255">seal</a>
holds a regular goal, which in
turn carries the context (the type of the proof variables).</p>
<p>In order to operate inside a goal one can use the <a class="libtac ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/elpi/elpi-ltac.elpi#L68">open</a> utility,
which postulates all proof variables using pi and loads the goal context
using <code class="highlight coq"><span class="o">=&gt;</span></code>.</p>
<p>Operating on multiple goals is doable, but not easy. In particular the
two proof context have to be related in some way.</p>
<p>The following simple
multi goal tactic shrinks the list of goals by removing duplicates.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> undup.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> lp:{{

  <span class="k k-ElpiKeyword">pred</span> <span class=" -ElpiFunction">same-goal</span> <span class="k k-ElpiMode">i:</span><span class="kt">sealed-goal</span>, <span class="k k-ElpiMode">i:</span><span class="kt">sealed-goal</span>.
  same-goal (nabla <span class=" -ElpiVariable">G1</span>) (nabla <span class=" -ElpiVariable">G2</span>) <span class="k k-ElpiKeyword">:-</span>
    <span class="k k-ElpiKeyword">pi</span> <span class=" -ElpiVariable">x</span>\ same-goal (<span class=" -ElpiVariable">G1</span> x) (<span class=" -ElpiVariable">G2</span> x).
  same-goal (seal (goal <span class=" -ElpiVariable">Ctx1</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">Ty1</span> <span class=" -ElpiVariable">P1</span> <span class=" -ElpiVariable">_</span>) <span class="k k-ElpiKeyword">as</span> <span class=" -ElpiVariable">G1</span>)
            (seal (goal <span class=" -ElpiVariable">Ctx2</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">Ty2</span> <span class=" -ElpiVariable">P2</span> <span class=" -ElpiVariable">_</span>) <span class="k k-ElpiKeyword">as</span> <span class=" -ElpiVariable">G2</span>) <span class="k k-ElpiKeyword">:-</span>
    same-ctx <span class=" -ElpiVariable">Ctx1</span> <span class=" -ElpiVariable">Ctx2</span><span class="k k-ElpiKeyword">,</span>
    <span class="c">% this is an elpi builtin, does not unify, just compare</span>
    <span class=" -ElpiVariable">Ty1</span> <span class="k k-ElpiKeyword">==</span> <span class=" -ElpiVariable">Ty2</span><span class="k k-ElpiKeyword">,</span>
    <span class=" -ElpiVariable">P1</span> <span class="k k-ElpiKeyword">=</span> <span class=" -ElpiVariable">P2</span>.

  <span class="k k-ElpiKeyword">pred</span> <span class=" -ElpiFunction">same-ctx</span> <span class="k k-ElpiMode">i:</span><span class="kt">goal-ctx</span>, <span class="k k-ElpiMode">i:</span><span class="kt">goal-ctx</span>.
  same-ctx <span class="k k-ElpiKeyword">[]</span> <span class="k k-ElpiKeyword">[]</span>.
  same-ctx <span class="k k-ElpiKeyword">[</span>decl <span class=" -ElpiVariable">V</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">T1</span><span class="k k-ElpiKeyword">|</span><span class=" -ElpiVariable">C1</span><span class="k k-ElpiKeyword">]</span> <span class="k k-ElpiKeyword">[</span>decl <span class=" -ElpiVariable">V</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">T2</span><span class="k k-ElpiKeyword">|</span><span class=" -ElpiVariable">C2</span><span class="k k-ElpiKeyword">]</span> <span class="k k-ElpiKeyword">:-</span>
    <span class="c">% TODO: we could compare up to permutation...</span>
    <span class=" -ElpiVariable">T1</span> <span class="k k-ElpiKeyword">==</span> <span class=" -ElpiVariable">T2</span><span class="k k-ElpiKeyword">,</span>
    same-ctx <span class=" -ElpiVariable">C1</span> <span class=" -ElpiVariable">C2</span>.

  <span class="k k-ElpiKeyword">pred</span> <span class=" -ElpiFunction">undup</span> <span class="k k-ElpiMode">i:</span><span class="kt">sealed-goal</span>, <span class="k k-ElpiMode">i:</span><span class="kt">list</span> <span class="kt">sealed-goal</span>, <span class="k k-ElpiMode">o:</span><span class="kt">list</span> <span class="kt">sealed-goal</span>.
  undup <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">[]</span> <span class="k k-ElpiKeyword">[]</span>.
  undup <span class=" -ElpiVariable">G</span> <span class="k k-ElpiKeyword">[</span><span class=" -ElpiVariable">G1</span><span class="k k-ElpiKeyword">|</span><span class=" -ElpiVariable">GN</span><span class="k k-ElpiKeyword">]</span> <span class=" -ElpiVariable">GN</span> <span class="k k-ElpiKeyword">:-</span> same-goal <span class=" -ElpiVariable">G</span> <span class=" -ElpiVariable">G1</span>.
  undup <span class=" -ElpiVariable">G</span> <span class="k k-ElpiKeyword">[</span><span class=" -ElpiVariable">G1</span><span class="k k-ElpiKeyword">|</span><span class=" -ElpiVariable">GN</span><span class="k k-ElpiKeyword">]</span> <span class="k k-ElpiKeyword">[</span><span class=" -ElpiVariable">G1</span><span class="k k-ElpiKeyword">|</span><span class=" -ElpiVariable">GL</span><span class="k k-ElpiKeyword">]</span> <span class="k k-ElpiKeyword">:-</span> undup <span class=" -ElpiVariable">G</span> <span class=" -ElpiVariable">GN</span> <span class=" -ElpiVariable">GL</span>.

  msolve <span class="k k-ElpiKeyword">[</span><span class=" -ElpiVariable">G1</span><span class="k k-ElpiKeyword">|</span><span class=" -ElpiVariable">GS</span><span class="k k-ElpiKeyword">]</span> <span class="k k-ElpiKeyword">[</span><span class=" -ElpiVariable">G1</span><span class="k k-ElpiKeyword">|</span><span class=" -ElpiVariable">GL</span><span class="k k-ElpiKeyword">]</span> <span class="k k-ElpiKeyword">:-</span>
    <span class="c">% TODO: we could find all duplicates, not just</span>
    <span class="c">% copies of the first one...</span>
    undup <span class=" -ElpiVariable">G1</span> <span class=" -ElpiVariable">GS</span> <span class=" -ElpiVariable">GL</span>.

}}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk55"><span class="kn">Elpi</span> <span class="kn">Typecheck</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">G2 <span class="kr">is</span> linear: name it _G2 (discard) or G2_ (<span class="kp">fresh</span> variable)
[<span class="nb">elpi</span>.typecheck,<span class="nb">elpi</span>]</blockquote><blockquote class="alectryon-message">G1 <span class="kr">is</span> linear: name it _G1 (discard) or G1_ (<span class="kp">fresh</span> variable)
[<span class="nb">elpi</span>.typecheck,<span class="nb">elpi</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk56"><span class="kn">Lemma</span> <span class="nf">test_undup</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">p</span> : P) (<span class="nv">q</span> : Q) : P /\ Q /\ P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P /\ Q /\ P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk57"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P /\ Q /\ P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk58"><span class="kp">repeat</span> <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk59" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><label class="goal-separator" for="tutorial-coq-elpi-tactic-v-chk59"><hr></label><div class="goal-conclusion">Q</div></blockquote><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk5a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><label class="goal-separator" for="tutorial-coq-elpi-tactic-v-chk5a"><hr></label><div class="goal-conclusion">P</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk5b"><span class="kn">Show Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">(<span class="kr">fun</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">p</span> : P) (<span class="nv">q</span> : Q) =&gt;
 conj <span class="nl">?Goal</span> (conj <span class="nl">?Goal0</span> <span class="nl">?Goal1</span>))</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk5c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><label class="goal-separator" for="tutorial-coq-elpi-tactic-v-chk5c"><hr></label><div class="goal-conclusion">Q</div></blockquote><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk5d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><label class="goal-separator" for="tutorial-coq-elpi-tactic-v-chk5d"><hr></label><div class="goal-conclusion">P</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk5e"><span class="kp">all</span>: <span class="nb">elpi</span> undup.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk5f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><label class="goal-separator" for="tutorial-coq-elpi-tactic-v-chk5f"><hr></label><div class="goal-conclusion">Q</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk60"><span class="kn">Show Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">(<span class="kr">fun</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">p</span> : P) (<span class="nv">q</span> : Q) =&gt;
 conj <span class="nl">?Goal0</span> (conj <span class="nl">?Goal</span> <span class="nl">?Goal0</span>))</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk61" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><label class="goal-separator" for="tutorial-coq-elpi-tactic-v-chk61"><hr></label><div class="goal-conclusion">Q</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk62">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk63">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P, Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> q.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>The two calls to show proof display, respectively:</p>
<pre class="code coq literal-block">
<span class="o">(</span><span class="kr">fun</span> <span class="o">(</span><span class="nv">P</span> <span class="nv">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="nv">p</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="nv">q</span> <span class="o">:</span> <span class="n">Q</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">conj</span> <span class="nl">?Goal</span> <span class="o">(</span><span class="n">conj</span> <span class="nl">?Goal0</span> <span class="nl">?Goal1</span><span class="o">))</span>
<span class="o">(</span><span class="kr">fun</span> <span class="o">(</span><span class="nv">P</span> <span class="nv">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="nv">p</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="nv">q</span> <span class="o">:</span> <span class="n">Q</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">conj</span> <span class="nl">?Goal0</span> <span class="o">(</span><span class="n">conj</span> <span class="nl">?Goal</span> <span class="nl">?Goal0</span><span class="o">))</span>
</pre>
<p>the proof term is the same but for the fact that after the tactic the first
and last missing subterm (incomplete proof tree branch) are represented by
the same hole. Indeed by solving one, we can also solve the other.</p>
<p>On the notion of sealed-goal it is easy to define the usual LCF combinators,
also known as Ltac tacticals. A few ones can be find in the
<a class="reference external" href="https://github.com/LPCIC/coq-elpi/blob/master/elpi/elpi-ltac.elpi">elpi-ltac.elpi file</a>
, see for example <a class="libtac ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/elpi/elpi-ltac.elpi#L43">try</a>.</p>
<p>As we hinted before, tactic arguments are attached to the goal, since
they can mention proof variables. So the Ltac code</p>
<pre class="code coq literal-block">
<span class="nb">intro</span> <span class="n">H</span><span class="o">;</span> <span class="nb">apply</span> <span class="n">H</span><span class="o">.</span>
</pre>
<p>has to be seen as 3 steps, starting from a goal G:</p>
<ul class="simple">
<li>introduction of <code class="highlight coq"><span class="n">H</span></code>, obtaining G1</li>
<li>setting the argument <code class="highlight coq"><span class="n">H</span></code>, obtaining G2</li>
<li>calling apply, obtaining G3</li>
</ul>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> argpass.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> lp:{{

 <span class="k k-ElpiKeyword">shorten</span> coq.ltac.{ open<span class="k k-ElpiKeyword">,</span> thenl<span class="k k-ElpiKeyword">,</span> all }.

  <span class="k k-ElpiKeyword">type</span> <span class=" -ElpiFunction">intro</span> <span class="kt">open-tactic</span>. <span class="c">% goal -&gt; list sealed-goal</span>
  intro <span class=" -ElpiVariable">G</span> <span class=" -ElpiVariable">GL</span> <span class="k k-ElpiKeyword">:-</span> refine {{ <span class="kr">fun</span> <span class="nv">H</span> =&gt; _ }} <span class=" -ElpiVariable">G</span> <span class=" -ElpiVariable">GL</span>.

  <span class="k k-ElpiKeyword">type</span> <span class=" -ElpiFunction">set-arg-n-hyp</span> <span class="kt">int</span> <span class="kt">-&gt;</span> <span class="kt">open-tactic</span>.
  set-arg-n-hyp <span class=" -ElpiVariable">N</span> (goal <span class=" -ElpiVariable">Ctx</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">as</span> <span class=" -ElpiVariable">G</span>) <span class="k k-ElpiKeyword">[</span><span class=" -ElpiVariable">SG1</span><span class="k k-ElpiKeyword">]</span> <span class="k k-ElpiKeyword">:-</span>
    std.nth <span class=" -ElpiVariable">N</span> <span class=" -ElpiVariable">Ctx</span> (decl <span class=" -ElpiVariable">X</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span>)<span class="k k-ElpiKeyword">,</span>
    coq.ltac.set-goal-arguments <span class="k k-ElpiKeyword">[</span>trm <span class=" -ElpiVariable">X</span><span class="k k-ElpiKeyword">]</span> <span class=" -ElpiVariable">G</span> (seal <span class=" -ElpiVariable">G</span>) <span class=" -ElpiVariable">SG1</span>.

  <span class="k k-ElpiKeyword">type</span> <span class=" -ElpiFunction">apply</span> <span class="kt">open-tactic</span>.
  <span class="k k-ElpiKeyword">app</span>ly (goal <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">[</span>trm <span class=" -ElpiVariable">T</span><span class="k k-ElpiKeyword">]</span> <span class="k k-ElpiKeyword">as</span> <span class=" -ElpiVariable">G</span>) <span class=" -ElpiVariable">GL</span> <span class="k k-ElpiKeyword">:-</span> refine <span class=" -ElpiVariable">T</span> <span class=" -ElpiVariable">G</span> <span class=" -ElpiVariable">GL</span>.

  msolve <span class=" -ElpiVariable">SG</span> <span class=" -ElpiVariable">GL</span> <span class="k k-ElpiKeyword">:-</span>
    all (thenl <span class="k k-ElpiKeyword">[</span> open intro<span class="k k-ElpiKeyword">,</span>
                 open (set-arg-n-hyp <span class="m m-ElpiInteger">0</span>)<span class="k k-ElpiKeyword">,</span>
                open <span class="k k-ElpiKeyword">app</span>ly <span class="k k-ElpiKeyword">]</span>) <span class=" -ElpiVariable">SG</span> <span class=" -ElpiVariable">GL</span>.

}}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Typecheck</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk64"><span class="kn">Lemma</span> <span class="nf">test_argpass</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) : P -&gt; P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk65"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">elpi</span> argpass.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Of course the tactic playing the role of <code class="highlight coq"><span class="nb">intro</span></code> could communicate back
a datum to be passed to what follows</p>
<pre class="code literal-block">
thenl [ open (tac1 Datum), open (tac2 Datum) ]
</pre>
<p>but the binder structure of <a class="type ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/coq-builtin.elpi#L253">sealed-goal</a> would prevent <code class="highlight coq"><span class="n">Datum</span></code> to mention
proof variables, that would otherwise escape the sealing. The utility
<a class="libtac ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/d4c4a9d21b64207d10e922fbd8a24fcff14b8a87/elpi/elpi-ltac.elpi#L36">set-goal-arguments</a></p>
<pre class="code literal-block">
coq.ltac.set-goal-arguments Args G G1 G1wArgs
</pre>
<p>tries to move <code class="highlight coq"><span class="n">Args</span></code> from the context of G to the one of G1. Relating the
two proof contexts is not obvious: you may need to write your own procedure
if the two contexts are very distant.</p>
</div>
<div class="section" id="tactic-in-terms">
<h1><a class="toc-backref" href="#id7">Tactic in terms</a></h1>
<p>Elpi tactics can be used inside terms via the usual <code class="highlight coq"><span class="kp">ltac</span><span class="o">:(...)</span></code>
quotation, but can also be exported in the term grammar.</p>
<p>Here we write a simple tactic for default values, which
optionally takes a bound to the search depth.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Tactic</span> default.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> lp:{{

  <span class="k k-ElpiKeyword">pred</span> <span class=" -ElpiFunction">default</span> <span class="k k-ElpiMode">i:</span><span class="kt">term</span>, <span class="k k-ElpiMode">i:</span><span class="kt">int</span>, <span class="k k-ElpiMode">o:</span><span class="kt">term</span>.
  default <span class=" -ElpiVariable">_</span> <span class="m m-ElpiInteger">0</span> <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">:-</span> coq.error <span class="s2">&quot;max search depth reached&quot;</span>.
  default {{nat}} <span class=" -ElpiVariable">_</span> {{<span class="mi">46</span>}}.
  default {{bool}} <span class=" -ElpiVariable">_</span> {{false}}.
  default {{list lp:<span class=" -ElpiVariable">A</span>}} <span class=" -ElpiVariable">Max</span> {{cons lp:<span class=" -ElpiVariable">D</span> nil}} <span class="k k-ElpiKeyword">:-</span>
    <span class=" -ElpiVariable">Max&#39;</span> <span class="k k-ElpiKeyword">is</span> <span class=" -ElpiVariable">Max</span> <span class="k k-ElpiKeyword">-</span> <span class="m m-ElpiInteger">1</span><span class="k k-ElpiKeyword">,</span> default <span class=" -ElpiVariable">A</span> <span class=" -ElpiVariable">Max&#39;</span> <span class=" -ElpiVariable">D</span>.

  solve (goal <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">T</span> <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">[]</span> <span class="k k-ElpiKeyword">as</span> <span class=" -ElpiVariable">G</span>) <span class=" -ElpiVariable">GL</span> <span class="k k-ElpiKeyword">:-</span>
    default <span class=" -ElpiVariable">T</span> <span class="m m-ElpiInteger">9999</span> <span class=" -ElpiVariable">P</span><span class="k k-ElpiKeyword">,</span>
    refine <span class=" -ElpiVariable">P</span> <span class=" -ElpiVariable">G</span> <span class=" -ElpiVariable">GL</span>.

}}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Typecheck</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Export</span> default.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">foo</span> : nat := default.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">bar</span> : list bool := default.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk66"><span class="kn">Print</span> foo.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">foo = <span class="mi">46</span>
     : nat</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk67"><span class="kn">Print</span> bar.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">bar = (false :: nil)%list
     : list bool</blockquote></div></div></small></span></pre><p>The grammar entries for Elpi tactics in terms take an arbitrary
number of arguments with the limitation that they are all terms:
you can't pass a string or an integer as would normally do.</p>
<p>Here we use Coq's primitive integers to pass the search depth
(in a compact way).</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Accumulate</span> default lp:{{
  solve (goal <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">T</span> <span class=" -ElpiVariable">_</span> <span class="k k-ElpiKeyword">[</span>trm (primitive (uint63 <span class=" -ElpiVariable">Max</span>))<span class="k k-ElpiKeyword">]</span> <span class="k k-ElpiKeyword">as</span> <span class=" -ElpiVariable">G</span>) <span class=" -ElpiVariable">GL</span> <span class="k k-ElpiKeyword">:-</span>
    coq.uint63-&gt;int <span class=" -ElpiVariable">Max</span> <span class=" -ElpiVariable">MaxI</span><span class="k k-ElpiKeyword">,</span>    
    default <span class=" -ElpiVariable">T</span> <span class=" -ElpiVariable">MaxI</span> <span class=" -ElpiVariable">P</span><span class="k k-ElpiKeyword">,</span>
    refine <span class=" -ElpiVariable">P</span> <span class=" -ElpiVariable">G</span> <span class=" -ElpiVariable">GL</span>.
}}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Elpi</span> <span class="kn">Typecheck</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Coq <span class="kn">Require Import</span>  Int63.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> int63_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk68"><span class="kn">Fail</span> <span class="kn">Definition</span> <span class="nf">baz</span> : list nat := default <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The command has indeed failed <span class="kr">with</span> message:
max search depth reached</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">baz</span> : list nat := default <span class="mi">2</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk69"><span class="kn">Print</span> baz.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">baz = (<span class="mi">46</span>%nat :: nil)%list
     : list nat</blockquote></div></div></small></span></pre><p>That is all folks!</p>
</div>
</div>
</div>
</div></body>
</html>

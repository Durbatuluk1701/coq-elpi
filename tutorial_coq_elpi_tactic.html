<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Tutorial on Coq tactics</title>
<meta name="author" content="Enrico Tassi" />
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.min.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.13.0+0.13.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="tutorial-on-coq-tactics">
<h1 class="title">Tutorial on Coq tactics</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Enrico Tassi</td></tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<!-- Elpi is an extension language that comes as a library
to be embedded into host applications such as Coq.

Elpi is a variant of ŒªProlog enriched with constraints.
ŒªProlog is a programming language designed to make it easy
to manipulate abstract syntax trees containing binders.
Elpi extends ŒªProlog with programming constructs that are
designed to make it easy to manipulate abstract syntax trees
containing metavariables (also called unification variables, or
evars in the Coq jargon).

This software, "coq-elpi", is a Coq plugin embedding Elpi and
exposing to the extension language Coq spefic data types (e.g. terms)
and API (e.g. to declare a new inductive type).

In order to get proper syntax highlighting using VSCode please install the
"gares.coq-elpi-lang" extension. In CoqIDE please chose "coq-elpi" in
Edit -> Preferences -> Colors. -->
<p>This tutorial focuses on the implementation of Coq tactics.</p>
<p>This tutorial assumes the reader is familiar with Elpi and the HOAS
representation of Coq terms; if it is not the case, please take a look at
these other tutorials first:
<a class="reference external" href="https://lpcic.github.io/coq-elpi/tutorial_elpi_lang.html">Elpi tutorial</a>
and <a class="reference external" href="https://lpcic.github.io/coq-elpi/tutorial_coq_elpi_HOAS.html">Coq HOAS tutorial</a>.</p>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#defining-tactics" id="id3">Defining tactics</a></li>
<li><a class="reference internal" href="#arguments-and-tactic-notation" id="id4">Arguments and Tactic Notation</a></li>
<li><a class="reference internal" href="#examples-assumption-and-set" id="id5">Examples: assumption and set</a></li>
<li><a class="reference internal" href="#id2" id="id6">The proof engine</a></li>
<li><a class="reference internal" href="#msolve-and-tactic-composition" id="id7">msolve and tactic composition</a></li>
<li><a class="reference internal" href="#tactic-in-terms" id="id8">Tactic in terms</a></li>
</ul>
</div>
<div class="section" id="defining-tactics">
<h1><a class="toc-backref" href="#id3">Defining tactics</a></h1>
<p>In Coq a proof is just a term, and an incomplete proof is just a term
with holes standing for the open goals.</p>
<p>When a proof starts there is just one hole (one goal) and its type
is the statement one wants to prove. Then proof construction makes
progress by instantiation: a term possibly containing holes is
grafted to the hole corresponding to the current goal. What a tactic
does behind the scenes is to synthesize this partial term.</p>
<p>Let's define a simple tactic that prints the current goal.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">From</span> elpi <span class="kn">Require Import</span> elpi.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Tactic show.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Accumulate lp:{{

  <span class="kp">solve</span> (goal Ctx _Trigger <span class="kt">Type</span> <span class="kn">Proof</span> _) _ :-
    coq.say <span class="s2">&quot;Goal:&quot;</span> Ctx <span class="s2">&quot;|-&quot;</span> <span class="kn">Proof</span> <span class="s2">&quot;:&quot;</span> <span class="kt">Type</span>.

}}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Typecheck.</span></span></span></pre><p>The tactic declaration is made of 3 parts.</p>
<p>The first one &quot;Elpi Tactic show.&quot; sets the current program to &quot;show&quot;.
Since it is declared as a &quot;Tactic&quot; some code is loaded automatically:</p>
<ul class="simple">
<li>APIs (eg <code class="highlight coq"><span class="name">coq</span><span class="operator">.</span><span class="name">say</span></code>) and data types (eg Coq terms) are loaded from
<a class="reference external" href="https://github.com/LPCIC/coq-elpi/blob/master/coq-builtin.elpi">coq-builtin.elpi</a></li>
<li>some utilities, like <code class="highlight coq"><span class="name">copy</span></code> or <code class="highlight coq"><span class="name">whd1</span></code> are loaded from
<a class="reference external" href="https://github.com/LPCIC/coq-elpi/blob/master/elpi/elpi-tactic-template.elpi">elpi-command-template.elpi</a></li>
</ul>
<p>The second one <code class="highlight coq"><span class="name">Elpi</span> <span class="name">Accumulate</span> <span class="operator">...</span></code> loads some extra code.
The <code class="highlight coq"><span class="name">Elpi</span> <span class="name">Accumulate</span> <span class="operator">...</span></code> family of commands lets one accumulate code
taken from:</p>
<ul class="simple">
<li>verbatim text <code class="highlight coq"><span class="name">Elpi</span> <span class="name">Accumulate</span> <span class="name">lp</span><span class="operator">:{{</span> <span class="operator">&lt;</span><span class="name">code</span><span class="operator">&gt;</span> <span class="operator">}}</span></code></li>
<li>source files <code class="highlight coq"><span class="name">Elpi</span> <span class="name">Accumulate</span> <span class="name">File</span> <span class="operator">&lt;</span><span class="name">path</span><span class="operator">&gt;</span></code></li>
<li>data bases (Db) <code class="highlight coq"><span class="name">Elpi</span> <span class="name">Accumulate</span> <span class="name">Db</span> <span class="operator">&lt;</span><span class="name">name</span><span class="operator">&gt;</span></code></li>
</ul>
<p>Accumulating code via inline text or file is equivalent, the AST of &lt;code&gt;
is stored in the .vo file (the external file does not need to be installed).
We invite the reader to look up the description of data bases in the tutorial
about commands.</p>
<p>Once all the code is accumulated <code class="highlight coq"><span class="name">Elpi</span> <span class="name">Typecheck</span></code> verifies that the
code does not contain the most frequent kind of mistakes. This command
considers some mistakes minor and only warns about them. You can
pass <code class="highlight coq"><span class="operator">-</span><span class="name">w</span> <span class="operator">+</span><span class="name">elpi</span><span class="operator">.</span><span class="name">typecheck</span></code> to <code class="highlight coq"><span class="name">coqc</span></code> to turn these warnings into errors.</p>
<p>The entry point for tactics is called <code class="highlight coq"><span class="keyword pseudo">solve</span></code> which maps a <code class="highlight coq"><span class="name">goal</span></code>
into a list of <code class="highlight coq"><span class="name">sealed</span><span class="operator">-</span><span class="name">goal</span></code> (representing subgoals).</p>
<p>Tactics written in Elpi can be invoked by prefixing its name with <code class="highlight coq"><span class="name">elpi</span></code>.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk0"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">tutorial</span> <span class="nv">x</span> <span class="nv">y</span>  : x + <span class="mi">1</span> = y.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x + <span class="mi">1</span> = y</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk1"><span class="highlight">elpi show.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Goal</span>: 
[decl c1 `y` (<span class="kn">global</span> (indt ¬´nat¬ª)), decl c0 `x` (<span class="kn">global</span> (indt ¬´nat¬ª))] 
|- X0 c0 c1 : 
app
 [<span class="kn">global</span> (indt ¬´eq¬ª), <span class="kn">global</span> (indt ¬´nat¬ª), 
  app
   [<span class="kn">global</span> (const ¬´Nat.add¬ª), c0, 
    app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)]], c1]</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x + <span class="mi">1</span> = y</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Abort</span>.</span></span></span></pre><p>In the Elpi code up there <code class="highlight coq"><span class="keyword namespace">Proof</span></code> is the hole for the current goal,
<code class="highlight coq"><span class="keyword type">Type</span></code> the statement to be proved and <code class="highlight coq"><span class="name">Ctx</span></code> the proof context (the list of
hypotheses). Since we don't assign <code class="highlight coq"><span class="keyword namespace">Proof</span></code> the tactic makes no progess.
Elpi prints somethinglike this:</p>
<pre class="code literal-block">
Goal:
[decl&nbsp;c0&nbsp;`x`&nbsp;(global&nbsp;(indt&nbsp;¬´nat¬ª)),&nbsp;decl&nbsp;c1&nbsp;`y`&nbsp;(global&nbsp;(indt&nbsp;¬´nat¬ª))]&nbsp;
|-&nbsp;X0&nbsp;c0&nbsp;c1&nbsp;:&nbsp;
   app [global&nbsp;(indt&nbsp;¬´eq¬ª),&nbsp;global&nbsp;(indt&nbsp;¬´nat¬ª),&nbsp;
      &nbsp;&nbsp;app&nbsp;[global&nbsp;(const&nbsp;¬´Nat.add¬ª),
             c0,&nbsp;app&nbsp;[global&nbsp;(indc&nbsp;¬´S¬ª),&nbsp;global&nbsp;(indc&nbsp;¬´O¬ª)]],
        c1]
</pre>
<p>The first line is the proof context:
proof variables are bound Elpi variables (here <code class="highlight coq"><span class="name">c0</span></code> and <code class="highlight coq"><span class="name">c1</span></code>), the context is
a list of predicates holding on them (their type in Coq). For example:</p>
<pre class="code literal-block">
decl&nbsp;c0&nbsp;`x`&nbsp;(global&nbsp;(indt&nbsp;¬´nat¬ª))
</pre>
<p>asserts that <code class="highlight coq"><span class="name">c0</span></code> (pretty printed as <code class="highlight coq"><span class="name">x</span></code>) has type <code class="highlight coq"><span class="name">nat</span></code>.</p>
<p>Then we see that the value of <code class="highlight coq"><span class="keyword namespace">Proof</span></code> is <code class="highlight coq"><span class="name">X0</span> <span class="name">c0</span> <span class="name">c1</span></code>. This means that the
proof of the current goal is represented by Elpi's variable <code class="highlight coq"><span class="name">X0</span></code> and that
the variable has <code class="highlight coq"><span class="name">c0</span></code> and <code class="highlight coq"><span class="name">c1</span></code> in scope (the proof term can use them).</p>
<p>Finally we see the type of the goal <code class="highlight coq"><span class="name">x</span> <span class="operator">+</span> <span class="literal number integer">1</span> <span class="operator">=</span> <span class="name">y</span></code>.</p>
<p>The <code class="highlight coq"><span class="name">_Trigger</span></code> component, which we did not print, is a variable that, when
assigned, trigger the elaboration of its value against the type of the goal
and obtains a value for <code class="highlight coq"><span class="keyword namespace">Proof</span></code> this way.</p>
<p>Keeping in mind that the solve predicate relates one goal to a list of
subgoals, we implement our first tactic which blindly tries to solve the goal.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Tactic blind.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Accumulate lp:{{
  <span class="kp">solve</span> (goal _ Trigger _ _ _) [] :- Trigger = {{<span class="mi">0</span>}}.
  <span class="kp">solve</span> (goal _ Trigger _ _ _) [] :- Trigger = {{I}}.
}}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Typecheck.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk2"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_blind</span> : <span class="kt">True</span> * nat.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kt">True</span> * nat)%type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk3"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kt">True</span> * nat)%type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk4"><span class="highlight"><span class="nb">split</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">nat</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk6"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">elpi blind.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk7"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">nat</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">elpi blind.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk8"><span class="highlight"><span class="kn">Show Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">(I, <span class="mi">0</span>)</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>Since the assignment of a term to <code class="highlight coq"><span class="name">Trigger</span></code> triggers its elaboration against
the expected type (the goal statement), assigning the wrong proof term
results in a failure which in turn results in the other clause being tried.</p>
<p>Assigning <code class="highlight coq"><span class="keyword namespace">Proof</span></code> directly is &quot;unsound&quot; in the sense that no automatic check
is performed.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Tactic blind_bad.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Accumulate lp:{{
  <span class="kp">solve</span> (goal _ _ _ <span class="kn">Proof</span> _) [] :- <span class="kn">Proof</span> = {{<span class="mi">0</span>}}.
  <span class="kp">solve</span> (goal _ _ _ <span class="kn">Proof</span> _) [] :- <span class="kn">Proof</span> = {{I}}.
}}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Typecheck.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk9"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_blind_bad</span> : <span class="kt">True</span> * nat.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kt">True</span> * nat)%type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chka"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kt">True</span> * nat)%type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chkb"><span class="highlight"><span class="nb">split</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chkc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">nat</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chkd"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">elpi blind_bad.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chke"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">nat</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">elpi blind_bad.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chkf"><span class="highlight"><span class="kn">Show Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">(<span class="mi">0</span>, <span class="mi">0</span>)</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk10"><span class="highlight"><span class="kn">Fail</span> <span class="kn">Qed</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">The command has indeed failed <span class="kr">with</span> message:
Illegal application: 
The term <span class="s2">&quot;@pair&quot;</span> of type
 <span class="s2">&quot;forall A B : Type, A -&gt; B -&gt; A * B&quot;</span>
cannot be applied to the terms
 <span class="s2">&quot;True&quot;</span> : <span class="s2">&quot;Prop&quot;</span>
 <span class="s2">&quot;nat&quot;</span> : <span class="s2">&quot;Set&quot;</span>
 <span class="s2">&quot;0&quot;</span> : <span class="s2">&quot;nat&quot;</span>
 <span class="s2">&quot;0&quot;</span> : <span class="s2">&quot;nat&quot;</span>
The <span class="mi">3</span>rd term has type <span class="s2">&quot;nat&quot;</span>
which should be coercible to <span class="s2">&quot;True&quot;</span>.</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Abort</span>.</span></span></span></pre><p>For now, this is all about the low level mechanics of tactics which is
developed further in the section <a class="reference internal" href="#the-proof-engine">The-proof-engine</a>.</p>
<p>We now focus on how to better integrate tactics written in Elpi with Ltac.</p>
<p>For a simple tactic like blind the list of subgoals is easy to write, since
it is empty, but in general one should collect all the holes in
the value of Proof (the checked proof term) and build goals out of them.</p>
<p>There is a family of APIs named after <code class="highlight coq"><span class="name builtin">refine</span></code>, the mother of all tactics, in
<a class="reference external" href="https://github.com/LPCIC/coq-elpi/blob/master/elpi/elpi-ltac.elpi">elpi-ltac.elpi</a>
which does this job for you.</p>
<p>Usually a tactic builds a (possibly partial) term and calls <code class="highlight coq"><span class="name builtin">refine</span></code> on it.</p>
<p>Let's rewrite the <code class="highlight coq"><span class="name">blind</span></code> tactic using this schema.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Tactic blind2.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Accumulate lp:{{
  <span class="kp">solve</span> G GL :- <span class="nb">refine</span> {{<span class="mi">0</span>}} G GL.
  <span class="kp">solve</span> G GL :- <span class="nb">refine</span> {{I}} G GL.
}}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Typecheck.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk11"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_blind2</span> : <span class="kt">True</span> * nat.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kt">True</span> * nat)%type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk12"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kt">True</span> * nat)%type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk13"><span class="highlight"><span class="nb">split</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk14" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">nat</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk15"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">elpi blind2.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk16"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">nat</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">elpi blind2.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>This schema works even if the term is partial, that is if it contains holes
corresponding to missing sub proofs. Let's write a tactic which opens
a few subgoals, let's implement the <code class="highlight coq"><span class="name builtin">split</span></code> tactic.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">Elpi's equality (that is, unification) on Coq terms corresponds to
alpha equivalence, we can use that to make our tactic less blind.</p>
</div>
<p>The head of a clause for the solve predicate is matched against the
goal. This operation cannot assign unification variables in the goal, only
variables in the clause's head.
As a consequence the following clause for <code class="highlight coq"><span class="keyword pseudo">solve</span></code> only triggers when
the statement features an explicit conjunction.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk17"><span class="highlight"><span class="kn">About</span> conj. <span class="c">(* conj : forall [A B : Prop], A -&gt; B -&gt; A /\ B *)</span></span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">conj : <span class="kr">forall</span> [A B : <span class="kt">Prop</span>], A -&gt; B -&gt; A /\ B

conj <span class="kr">is</span> not universe polymorphic
<span class="kn">Arguments</span> conj [A B]%type_scope _ _
Expands to: Constructor Coq.Init.Logic.conj</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Tactic <span class="nb">split</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Accumulate lp:{{
  <span class="kp">solve</span> (goal _ _ {{ _ /\ _ }} _ _ <span class="kr">as</span> G) GL :- !,
    % conj has <span class="mi">4</span> arguments, but two are implicits
    % (_ are added <span class="kr">for</span> them <span class="kn">and</span> are inferred <span class="kn">from</span> the goal)
    <span class="nb">refine</span> {{ conj _ _ }} G GL.

  <span class="kp">solve</span> _ _ :-
    % This signals a failure <span class="kr">in</span> the <span class="kn">Ltac</span> <span class="nf">model</span>. A failure
    % <span class="kr">in</span> Elpi, that <span class="kr">is</span> no more cluases to <span class="kp">try</span>, <span class="kr">is</span> a fatal
    % error that cannot be catch <span class="bp">by</span> <span class="kn">Ltac</span> <span class="nf">combinators</span> like <span class="kp">repeat</span>.
    coq.<span class="kp">ltac</span>.<span class="kp">fail</span> _ <span class="s2">&quot;not a conjunction&quot;</span>.
}}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Typecheck.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk18"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_split</span> : <span class="kr">exists</span> <span class="nv">t</span> : <span class="kt">Prop</span>, <span class="kt">True</span> /\ <span class="kt">True</span> /\ t.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">t</span> : <span class="kt">Prop</span>, <span class="kt">True</span> /\ <span class="kt">True</span> /\ t</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk19"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">t</span> : <span class="kt">Prop</span>, <span class="kt">True</span> /\ <span class="kt">True</span> /\ t</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk1a"><span class="highlight"><span class="nb">eexists</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span> /\ <span class="kt">True</span> /\ <span class="nl">?t</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk1b"><span class="highlight"><span class="kp">repeat</span> elpi <span class="nb">split</span>. <span class="c">(* The failure is catched by Ltac&#39;s repeat *)</span></span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk1c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk1d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="nl">?t</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight"><span class="c">(* Remark that the last goal is left untouched, since</span>
<span class="c">   it did not match the pattern {{ _ /\ _ }}. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kp">all</span>: elpi blind.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk1e"><span class="highlight"><span class="kn">Show Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">(ex_intro (<span class="kr">fun</span> <span class="nv">t</span> : <span class="kt">Prop</span> =&gt; <span class="kt">True</span> /\ <span class="kt">True</span> /\ t) <span class="kt">True</span>
   (conj I (conj I I)))</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>The tactic <code class="highlight coq"><span class="name builtin">split</span></code> succeeds twice, stopping on the two identical goals <code class="highlight coq"><span class="keyword type">True</span></code> and
the one which is an evar of type <code class="highlight coq"><span class="keyword type">Prop</span></code>.</p>
<p>We then invoke <code class="highlight coq"><span class="name">blind</span></code> on all goals. In the third case the type checking
constraint triggered by assigning <code class="highlight coq"><span class="operator">{{</span><span class="literal number integer">0</span><span class="operator">}</span></code>} to <code class="highlight coq"><span class="keyword namespace">Proof</span></code> fails because
its type <code class="highlight coq"><span class="operator">{{</span><span class="name">nat</span><span class="operator">}}</span></code> is not of sort <code class="highlight coq"><span class="keyword type">Prop</span></code>, so it backtracks and picks <code class="highlight coq"><span class="operator">{{</span><span class="name">I</span><span class="operator">}}</span></code>.</p>
<p>Another common way to build an Elpi tactic is to synthesize a term and
then call some Ltac piece of code finishing the work.</p>
<p><code class="highlight coq"><span class="name">coq</span><span class="operator">.</span><span class="keyword pseudo">ltac</span><span class="operator">.</span><span class="name">call</span></code> invokes an Ltac piece of code passing to it the desired
arguments. Then it builds the list of subgoals.</p>
<p>Here we pass an integer, passed to fail, and a term, passed to apply.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">helper_split2</span> n t := <span class="kp">fail</span> n || <span class="nb">apply</span> t.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Tactic split2.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Accumulate lp:{{
  <span class="kp">solve</span> (goal _ _ {{ _ /\ _ }} _ _ <span class="kr">as</span> G) GL :-
    coq.<span class="kp">ltac</span>.call <span class="s2">&quot;helper_split2&quot;</span> [int <span class="mi">0</span>, trm {{ conj }}] G GL.
  <span class="kp">solve</span> _ _ :-
    coq.<span class="kp">ltac</span>.<span class="kp">fail</span> _ <span class="s2">&quot;not a conjunction&quot;</span>.
}}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Typecheck.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk1f"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_split2</span> : <span class="kr">exists</span> <span class="nv">t</span> : <span class="kt">Prop</span>, <span class="kt">True</span> /\ <span class="kt">True</span> /\ t.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">t</span> : <span class="kt">Prop</span>, <span class="kt">True</span> /\ <span class="kt">True</span> /\ t</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk20"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">t</span> : <span class="kt">Prop</span>, <span class="kt">True</span> /\ <span class="kt">True</span> /\ t</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk21"><span class="highlight"><span class="nb">eexists</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span> /\ <span class="kt">True</span> /\ <span class="nl">?t</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk22"><span class="highlight"><span class="kp">repeat</span> elpi split2.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk23" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk24" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="nl">?t</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kp">all</span>: elpi blind.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre></div>
<div class="section" id="arguments-and-tactic-notation">
<h1><a class="toc-backref" href="#id4">Arguments and Tactic Notation</a></h1>
<p>Elpi tactics can receive arguments. Arguments are received as a list, which
is the last argument of the goal constructor. This suggests that arguments
are attached to the current goal being observed, but we will dive into
this detail later on.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Tactic print_args.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Accumulate lp:{{
  <span class="kp">solve</span> (goal _ _ _ _ Args) _ :- coq.say Args.
}}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Typecheck.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk25"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_print_args</span> : <span class="kt">True</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk26"><span class="highlight">elpi print_args <span class="mi">1</span> x <span class="s2">&quot;a b&quot;</span> (<span class="mi">1</span> = <span class="mi">0</span>).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">[int <span class="mi">1</span>, str x, str a b, 
 trm
  (app
    [<span class="kn">global</span> (indt ¬´eq¬ª), X0, 
     app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)], <span class="kn">global</span> (indc ¬´O¬ª)])]</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Abort</span>.</span></span></span></pre><p>The convention is that numbers like <code class="highlight coq"><span class="literal number integer">1</span></code> are passed a <code class="highlight coq"><span class="name">int</span> <span class="operator">&lt;</span><span class="name">arg</span><span class="operator">&gt;</span></code>,
identifiers or strings are passed as <code class="highlight coq"><span class="name">str</span> <span class="operator">&lt;</span><span class="name">arg</span><span class="operator">&gt;</span></code> and terms
have to be put between parentheses.</p>
<p>Remark that terms are received in raw format, eg before elaboration.
Indeed the type argument to <code class="highlight coq"><span class="name">eq</span></code> is a variable.
One can use APIs like <code class="highlight coq"><span class="name">coq</span><span class="operator">.</span><span class="name">elaborate</span><span class="operator">-</span><span class="name">skeleton</span></code> to infer holes like <code class="highlight coq"><span class="name">X0</span></code>.</p>
<p>See the <code class="highlight coq"><span class="name">argument</span></code> data type in 
<a class="reference external" href="https://github.com/LPCIC/coq-elpi/blob/master/coq-builtin.elpi">coq-builtin.elpi</a>.
for a detailed decription of all the arguments a tactic can receive.</p>
<p>Now let's write a tactic which behave pretty much like the <code class="highlight coq"><span class="name builtin">refine</span></code> one
from Coq, but prints what it does.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Tactic <span class="nb">refine</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Accumulate lp:{{
  <span class="kp">solve</span> (goal _ _ Ty _ [trm S] <span class="kr">as</span> G) GL :-
    % check S elaborates to T of type Ty (the goal)
    coq.elaborate-skeleton S Ty T ok,

    coq.say <span class="s2">&quot;Using&quot;</span> {coq.term-&gt;string T}
            <span class="s2">&quot;of type&quot;</span> {coq.term-&gt;string Ty},

    % since T <span class="kr">is</span> already checked, we don&#39;t check it again
    <span class="nb">refine</span>.no_check T G GL.

  <span class="kp">solve</span> (goal _ _ _ _ [trm S]) _ :-
    Msg <span class="kr">is</span> {coq.term-&gt;string S} ^ <span class="s2">&quot; does not fit&quot;</span>,
    coq.<span class="kp">ltac</span>.<span class="kp">fail</span> _ Msg.
}}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Typecheck.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk27"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_refine</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">H</span> : P -&gt; Q) : Q.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P -&gt; Q</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Q</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk28"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P -&gt; Q</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Q</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk29"><span class="highlight"><span class="kn">Fail</span> elpi <span class="nb">refine</span> (H).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">The command has indeed failed <span class="kr">with</span> message:
Tactic failure: H does not fit.</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P -&gt; Q</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Q</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk2a"><span class="highlight">elpi <span class="nb">refine</span> (H _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">Using H <span class="nl">?p</span> of type Q</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P -&gt; Q</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Abort</span>.</span></span></span></pre><p>It is customary to use the Tactic Notation command to attach a nicer syntax
to Elpi tactics.</p>
<p>In particular elpi tacname accepts as arguments the following bridges
for Ltac:</p>
<ul class="simple">
<li><code class="highlight coq"><span class="name">ltac_string</span><span class="operator">:(</span><span class="name">v</span><span class="operator">)</span></code> (for <code class="highlight coq"><span class="name">v</span></code> of type <code class="highlight coq"><span class="name">string</span></code> or <code class="highlight coq"><span class="keyword namespace">ident</span></code>)</li>
<li><code class="highlight coq"><span class="name">ltac_int</span><span class="operator">:(</span><span class="name">v</span><span class="operator">)</span></code> (for <code class="highlight coq"><span class="name">v</span></code> of type <code class="highlight coq"><span class="name">int</span></code> or <code class="highlight coq"><span class="name">integer</span></code>)</li>
<li><code class="highlight coq"><span class="name">ltac_term</span><span class="operator">:(</span><span class="name">v</span><span class="operator">)</span></code> (for <code class="highlight coq"><span class="name">v</span></code> of type <code class="highlight coq"><span class="keyword pseudo">constr</span></code> or <code class="highlight coq"><span class="name">open_constr</span></code> or <code class="highlight coq"><span class="keyword pseudo">uconstr</span></code> or <code class="highlight coq"><span class="name">hyp</span></code>)</li>
<li><code class="highlight coq"><span class="name">ltac_</span><span class="operator">(</span><span class="name">string</span><span class="operator">|</span><span class="name">int</span><span class="operator">|</span><span class="name">term</span><span class="operator">)</span><span class="name">_list</span><span class="operator">:(</span><span class="name">v</span><span class="operator">)</span></code> (for <code class="highlight coq"><span class="name">v</span></code> of type <code class="highlight coq"><span class="name">list</span></code> of ...)</li>
</ul>
<p>Note that the Ltac type associates some semantics to the action of passing
the arguments. For example <code class="highlight coq"><span class="name">hyp</span></code> will accept an identifier only if it is
an hypotheses of the context. While <code class="highlight coq"><span class="keyword pseudo">uconstr</span></code> does not type check the term,
which is the recommended way to pass terms to an Elpi tactic (since it is
likely to be typed anyway by the Elpi tactic).</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;use&quot;</span> <span class="kp">uconstr</span>(t) :=
  elpi <span class="nb">refine</span> ltac_term:(t).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;use&quot;</span> hyp(t) :=
  elpi <span class="nb">refine</span> ltac_term:(t).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk2b"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_use</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">H</span> : P -&gt; Q) (<span class="nv">p</span> : P) : Q.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P -&gt; Q</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Q</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk2c"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P -&gt; Q</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Q</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk2d"><span class="highlight">use (H _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">Using H <span class="nl">?p</span> of type Q</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P -&gt; Q</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk2e"><span class="highlight"><span class="kn">Fail</span> use q.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">The command has indeed failed <span class="kr">with</span> message:
No such hypothesis: q</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P -&gt; Q</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk2f"><span class="highlight">use p.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">Using p of type P</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;print&quot;</span> uconstr_list_sep(l, <span class="s2">&quot;,&quot;</span>) :=
  elpi print_args ltac_term_list:(l).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk30"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_print</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">H</span> : P -&gt; Q) (<span class="nv">p</span> : P) : Q.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P -&gt; Q</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Q</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk31"><span class="highlight">print P, p, (H p).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">[trm c0, trm c3, trm (app [c2, c3])]</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P -&gt; Q</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Q</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Abort</span>.</span></span></span></pre></div>
<div class="section" id="examples-assumption-and-set">
<h1><a class="toc-backref" href="#id5">Examples: assumption and set</a></h1>
<p>A very simple tactic we can implement is assumption: we look up in the proof
context for an hypothesis which unifies with the goal.
Recall that Ctx is made of decl and def clauses (here, for simplicity, we
ignore the latter case).</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Tactic <span class="bp">assumption</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Accumulate lp:{{
  <span class="kp">solve</span> (goal Ctx _ Ty _ _ <span class="kr">as</span> G) GL :-
    % H <span class="kr">is</span> the name of hyp, Ty <span class="kr">is</span> the goal
    std.mem Ctx (decl H _ Ty),
    <span class="nb">refine</span> H G GL.
  <span class="kp">solve</span> _ _ :-
    coq.<span class="kp">ltac</span>.<span class="kp">fail</span> _ <span class="s2">&quot;no such hypothesis&quot;</span>.
}}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Typecheck.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk32"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_assumption</span>  (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">p</span> : P) (<span class="nv">q</span> : Q) : P /\ id Q.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Q</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P /\ id Q</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk33"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Q</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P /\ id Q</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk34"><span class="highlight"><span class="nb">split</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Q</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk35" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Q</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="tutorial-coq-elpi-tactic-v-chk35"><hr></label><div class="goal-conclusion"><span class="highlight">id Q</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk36"><span class="highlight">elpi <span class="bp">assumption</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Q</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">id Q</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk37"><span class="highlight"><span class="kn">Fail</span> elpi <span class="bp">assumption</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">The command has indeed failed <span class="kr">with</span> message:
Tactic failure: no such hypothesis.</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Q</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">id Q</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Abort</span>.</span></span></span></pre><p>As we hinted before, Elpi's equality is alpha equivalence. In the second
goal the assumption has type <code class="highlight coq"><span class="name">Q</span></code> but the goal has type <code class="highlight coq"><span class="name">id</span> <span class="name">Q</span></code> which is
convertible (unifiable, for Coq's unification) to <code class="highlight coq"><span class="name">Q</span></code>.</p>
<p>Let's improve out tactic looking for an assumption which is unifiable with
the goal, an not just alpha convertible</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Tactic assumption2.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Accumulate lp:{{
  <span class="kp">solve</span> (goal Ctx _ Ty _ _ <span class="kr">as</span> G) GL :-
    % std.mem <span class="kr">is</span> backtracking (std.mem! would stop <span class="nb">at</span> the <span class="kp">first</span> hit)
    std.mem Ctx (decl H _ Ty&#39;), coq.<span class="nb">unify</span>-leq Ty&#39; Ty ok,
    <span class="nb">refine</span> H G GL.
  <span class="kp">solve</span> _ _ :-
    coq.<span class="kp">ltac</span>.<span class="kp">fail</span> _ <span class="s2">&quot;no such hypothesis&quot;</span>.
}}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Typecheck.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk38"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_assumption2</span>  (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">p</span> : P) (<span class="nv">q</span> : Q) : P /\ id Q.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Q</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P /\ id Q</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk39"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Q</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P /\ id Q</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk3a"><span class="highlight"><span class="nb">split</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Q</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk3b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Q</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="tutorial-coq-elpi-tactic-v-chk3b"><hr></label><div class="goal-conclusion"><span class="highlight">id Q</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kp">all</span>: elpi assumption2.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p><code class="highlight coq"><span class="name builtin">refine</span></code> does unify the type of goal with the type of the term, hence we can
just write the follwing code, which is very close to our initial <code class="highlight coq"><span class="name">blind</span></code>
tactic, but it picks candidates from the context.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Tactic assumption3.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Accumulate lp:{{
  <span class="kp">solve</span> (goal Ctx _ _ _ _ <span class="kr">as</span> G) GL :-
    std.mem Ctx (decl H _ _),
    <span class="nb">refine</span> H G GL.
  <span class="kp">solve</span> _ _ :-
    coq.<span class="kp">ltac</span>.<span class="kp">fail</span> _ <span class="s2">&quot;no such hypothesis&quot;</span>.
}}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Typecheck.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk3c"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_assumption3</span>  (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">p</span> : P) (<span class="nv">q</span> : Q) : P /\ id Q.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Q</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P /\ id Q</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk3d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Q</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P /\ id Q</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk3e"><span class="highlight"><span class="nb">split</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Q</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk3f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Q</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="tutorial-coq-elpi-tactic-v-chk3f"><hr></label><div class="goal-conclusion"><span class="highlight">id Q</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kp">all</span>: elpi assumption3.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>Now let's write a tactic which takes a term, possibly with holes, and
makes a let-int out of it, a bit like the <code class="highlight coq"><span class="name builtin">set</span></code> tactic.</p>
<p>It will be the occasion to explain the <code class="highlight coq"><span class="name">copy</span></code> utility.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Tactic find.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Accumulate lp:{{

<span class="kp">solve</span> (goal _ _ T _ [trm X]) _ :-
  pi x\
    copy X x =&gt; copy T (Tabs x),
    <span class="kr">if</span> (occurs x (Tabs x))
       (coq.say <span class="s2">&quot;found&quot;</span> {coq.term-&gt;string X})
       (coq.<span class="kp">ltac</span>.<span class="kp">fail</span> _ <span class="s2">&quot;not found&quot;</span>).
}}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Typecheck.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk40"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_find</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) : P /\ P.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P /\ P</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk41"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P /\ P</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk42"><span class="highlight">elpi find (P).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">found P</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P /\ P</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk43"><span class="highlight"><span class="kn">Fail</span> elpi find (Q).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">The command has indeed failed <span class="kr">with</span> message:
Tactic failure: not found.</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P /\ P</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk44"><span class="highlight">elpi find (P /\ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">found P /\ P</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P /\ P</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Abort</span>.</span></span></span></pre><p>This first approximation only prints the term it found, or better the first
intance of the given term.</p>
<p>Now lets focus on <code class="highlight coq"><span class="name">copy</span></code>. The standard
Coq library <a class="reference external" href="https://github.com/LPCIC/coq-elpi/blob/master/elpi/coq-lib.elpi">coq-lib.elpi</a>.
(loaded by the command template) contains a definition of copy
for terms and declarations. An excerpt:</p>
<pre class="code literal-block">
copy X X :- name X.
copy (global _ as C) C.
copy (fun N T F) (fun N T1 F1).
  copy T T1, pi x\ copy (F x) (F1 x).
copy (app L) (app L1) :- !, std.map L copy L1.
</pre>
<p>Copy implements the identity: it builds, recursively, a copy of the first
term into the second argument. Unless one loads in the context a new clause,
which takes precedence over the identity ones. Here we load</p>
<pre class="code literal-block">
copy X x
</pre>
<p>which, at run time, looks like</p>
<pre class="code literal-block">
copy (app [global (indt ¬´andn¬ª), sort prop, sort prop, c0, X0 c0 c1]) c2
</pre>
<p>and that clause masks the one for <code class="highlight coq"><span class="name">app</span></code> when the sub-term being copied is
matches <code class="highlight coq"><span class="operator">(</span><span class="name">P</span> <span class="operator">/\</span> <span class="name">_</span><span class="operator">)</span></code>.</p>
<p>Now let's refine the tactic to build a let-in, and complain if the
desired name is already taken.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Tactic <span class="nb">set</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Accumulate lp:{{

<span class="kp">solve</span> (goal _ _ T _ [str ID, trm X] <span class="kr">as</span> G) GL :-
  pi x\
    copy X x =&gt; copy T (Tabs x),
    <span class="kr">if</span> (occurs x (Tabs x))
       (<span class="kr">if</span> (coq.<span class="kp">ltac</span>.id-free? ID G) true
           (coq.warn ID <span class="s2">&quot;is already taken, Elpi will make a name up&quot;</span>),
        coq.id-&gt;name ID Name,
        Hole x = {{ _ : lp:{{ Tabs x }} }}, % a hole <span class="kr">with</span> a type
        <span class="nb">refine</span> (<span class="kr">let</span> <span class="nv">Name</span> <span class="nv">_</span> <span class="nv">X</span> <span class="nv">x</span>\ Hole x) G GL)
       (coq.<span class="kp">ltac</span>.<span class="kp">fail</span> _ <span class="s2">&quot;not found&quot;</span>).

}}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Typecheck.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk45"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_set</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) : P /\ P.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P /\ P</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk46"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P /\ P</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk47"><span class="highlight">elpi <span class="nb">set</span> <span class="s2">&quot;x&quot;</span> (P).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">P</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x /\ x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk48"><span class="highlight"><span class="nb">unfold</span> x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">P</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P /\ P</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk49"><span class="highlight"><span class="kn">Fail</span> elpi <span class="nb">set</span> <span class="s2">&quot;x&quot;</span> (Q).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">The command has indeed failed <span class="kr">with</span> message:
Tactic failure: not found.</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">P</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P /\ P</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk4a"><span class="highlight">elpi <span class="nb">set</span> <span class="s2">&quot;x&quot;</span> (P /\ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">x <span class="kr">is</span> already taken, Elpi will make a name up
[lib,elpi]</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">P</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">elpi_ctx_entry_3_</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">P /\ P</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">elpi_ctx_entry_3_</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Abort</span>.</span></span></span></pre><p>The new hole is annotated with a type. Here we use quotations to write
that term, but we could have used the commodity macro</p>
<pre class="code literal-block">
&#64;cast (Hole x) (Tabs x)
</pre>
<p>which unfolds to</p>
<pre class="code literal-block">
let _ (Tabs x) (Hole x) y\y
</pre>
<p>which is how &quot;type casts&quot; are represented in the HOAS of terms.</p>
<p>For more example of (basic) tactics written in Elpi see the
<a class="reference external" href="https://github.com/LPCIC/coq-elpi/tree/master/apps/eltac">eltac app</a>.</p>
</div>
<div class="section" id="id2">
<span id="the-proof-engine"></span><h1><a class="toc-backref" href="#id6">The proof engine</a></h1>
<p>In this section we dive into the details of the proof engine, that is
how goals are represented in Elpi and things are wired up behind the scenes.</p>
<p>Let's inspect the proof state a bit deeper:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Tactic show_more.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Accumulate lp:{{

  <span class="kp">solve</span> (goal Ctx _Trigger <span class="kt">Type</span> <span class="kn">Proof</span> _) _ :-
    coq.say <span class="s2">&quot;Goal:&quot;</span> Ctx <span class="s2">&quot;|-&quot;</span> <span class="kn">Proof</span> <span class="s2">&quot;:&quot;</span> <span class="kt">Type</span>,
    coq.say <span class="s2">&quot;Proof state:&quot;</span>,
    coq.sigma.print.

}}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Typecheck.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk4b"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_show_more</span> <span class="nv">x</span> : x + <span class="mi">1</span> = <span class="mi">0</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x + <span class="mi">1</span> = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk4c"><span class="highlight">elpi show_more.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Goal</span>: [decl c0 `x` (<span class="kn">global</span> (indt ¬´nat¬ª))] |- X0 c0 : 
app
 [<span class="kn">global</span> (indt ¬´eq¬ª), <span class="kn">global</span> (indt ¬´nat¬ª), 
  app
   [<span class="kn">global</span> (const ¬´Nat.add¬ª), c0, 
    app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)]], <span class="kn">global</span> (indc ¬´O¬ª)]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Proof</span> state:</span></blockquote><blockquote class="alectryon-message"><span class="highlight"> {c0} : decl c0 `x` (<span class="kn">global</span> (indt ¬´nat¬ª))
   ?- <span class="nb">evar</span> (X1 c0) 
       (app
         [<span class="kn">global</span> (indt ¬´eq¬ª), <span class="kn">global</span> (indt ¬´nat¬ª), 
          app
           [<span class="kn">global</span> (const ¬´Nat.add¬ª), c0, 
            app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)]], 
          <span class="kn">global</span> (indc ¬´O¬ª)]) (X0 c0)  /* suspended on X1, X0 */
EVARS:
 <span class="nl">?X56</span>==[x |- x + <span class="mi">1</span> = <span class="mi">0</span>] (goal <span class="nb">evar</span>) {<span class="nl">?Goal</span>}
 <span class="nl">?X55</span>==[ |- <span class="kr">forall</span> <span class="nv">x</span> : nat, x + <span class="mi">1</span> = <span class="mi">0</span> =&gt; <span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; <span class="nl">?Goal</span>] (goal <span class="nb">evar</span>)
 <span class="nl">?X54</span>==[x |- <span class="kt">Type</span> =&gt; nat] (parameter A of @eq)
 <span class="nl">?X53</span>==[ |- <span class="kt">Set</span> =&gt; nat] (<span class="kp">type of</span> x)

UNIVERSES:
ALGEBRAIC UNIVERSES:{Tutorial.<span class="mi">3</span>}
UNDEFINED UNIVERSES:Tutorial.<span class="mi">3</span> := <span class="kt">Set</span>
WEAK CONSTRAINTS:
SHELF:||
FUTURE GOALS STACK:||<span class="nl">?X54</span>
<span class="nl">?X53</span>

Coq-Elpi mapping:
RAW:
<span class="nl">?X56</span> &lt;-&gt; X1
ELAB:
<span class="nl">?X56</span> &lt;-&gt; X0
</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x + <span class="mi">1</span> = <span class="mi">0</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Abort</span>.</span></span></span></pre><p>In addition to the goal we print the Elpi and Coq proof state,
plus the link between them.
The proof engine is the collection of goals together with their types.</p>
<p>In the side of Elpi this state is represented by constraints for the &quot;evar&quot;
predicate.</p>
<p>One can recognize the set of bound variables <code class="highlight coq"><span class="operator">{</span><span class="name">c0</span><span class="operator">}</span></code>, the hypothetical
context of clauses about these variable (that also corresponds to the proof
context), and finally the suspended goal <code class="highlight coq"><span class="name builtin">evar</span> <span class="operator">(</span><span class="name">X1</span> <span class="name">c0</span><span class="operator">)</span> <span class="operator">..</span> <span class="operator">(</span><span class="name">X0</span> <span class="name">c0</span><span class="operator">)</span></code>.</p>
<p>The set of constraints on <code class="highlight coq"><span class="name builtin">evar</span></code> represents the Coq data structure called
sigma (hence the name of the API to print it) that is used to
represent the proof state in Coq. It is printed just afterwards:</p>
<pre class="code literal-block">
EVARS:
 ?X56==[x |- x + 1 = 0] (goal evar) {?Goal}

Coq-Elpi mapping:
RAW:
?X56 &lt;-&gt; X1
ELAB:
?X56 &lt;-&gt; X0
</pre>
<p>Here <code class="highlight coq"><span class="name label">?X56</span></code> is a Coq evar linked with Elpi's <code class="highlight coq"><span class="name">X0</span></code> and <code class="highlight coq"><span class="name">X1</span></code>.
<code class="highlight coq"><span class="name">X1</span></code> represents the goal (the trigger) while <code class="highlight coq"><span class="name">X0</span></code> represent the proof.
The meaning of the <code class="highlight coq"><span class="name builtin">evar</span></code> Elpi predicate linking the two is that the term
assigned to the trigger <code class="highlight coq"><span class="name">X1</span></code> has to be elaborated to the final proof term <code class="highlight coq"><span class="name">X0</span></code>,
that should be a well typed term of type <code class="highlight coq"><span class="name">x</span> <span class="operator">+</span> <span class="literal number integer">1</span> <span class="operator">=</span> <span class="literal number integer">0</span></code>.
This means that when an Elpi tactic assigns a value to <code class="highlight coq"><span class="name">X1</span></code> some procedure to
turn that value into <code class="highlight coq"><span class="name">X0</span></code> is triggered. That procedure is called elaboration and
it is currently implemented by calling the <code class="highlight coq"><span class="name">coq</span><span class="operator">.</span><span class="name">elaborate</span><span class="operator">-</span><span class="name">skeleton</span></code> API.</p>
<p>Given this set up, it is impossible to use a term of the wrong type as a
proof. Lets declare simle tactic that tries <code class="highlight coq"><span class="literal number integer">0</span></code> and <code class="highlight coq"><span class="name">I</span></code> as proof terms for a
goal, without even looking at it.</p>
<p>The refine utility simply assigns the trigger and then calls the
<code class="highlight coq"><span class="name">coq</span><span class="operator">.</span><span class="keyword pseudo">ltac</span><span class="operator">.</span><span class="name">collect</span><span class="operator">-</span><span class="name">goals</span></code> API on the elaborated proof term to get the list
of sub goals</p>
<p>Let's rewrite the split tactic using only low level operations.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Tactic split_ll.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Accumulate lp:{{
  <span class="kp">solve</span> (goal Ctx Trigger {{ lp:A /\ lp:B }} <span class="kn">Proof</span> []) GL :- !,
    Trigger = {{ conj _ _ }},
    <span class="kn">Proof</span> = {{ conj lp:Pa lp:Pb }},
    GL = [seal G1, seal G2],
    G1 = goal Ctx _ A Pa [],
    G2 = goal Ctx _ B Pb [].
  <span class="kp">solve</span> _ _ :-
    coq.<span class="kp">ltac</span>.<span class="kp">fail</span> _ <span class="s2">&quot;not a conjunction&quot;</span>.
}}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Typecheck.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk4d"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_split_ll</span> : <span class="kr">exists</span> <span class="nv">t</span> : <span class="kt">Prop</span>, <span class="kt">True</span> /\ <span class="kt">True</span> /\ t.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">t</span> : <span class="kt">Prop</span>, <span class="kt">True</span> /\ <span class="kt">True</span> /\ t</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk4e"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">t</span> : <span class="kt">Prop</span>, <span class="kt">True</span> /\ <span class="kt">True</span> /\ t</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk4f"><span class="highlight"><span class="nb">eexists</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span> /\ <span class="kt">True</span> /\ <span class="nl">?t</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk50"><span class="highlight"><span class="kp">repeat</span> elpi split_ll.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk51" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk52" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="nl">?t</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kp">all</span>: elpi blind.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>Crafting by hand the list of subgoal is not easy.
In particular here we did not set up the new trigger for <code class="highlight coq"><span class="name">Pa</span></code> and <code class="highlight coq"><span class="name">Pb</span></code>, nor
seal the goals appropriately.</p>
<p>The <code class="highlight coq"><span class="name">coq</span><span class="operator">.</span><span class="keyword pseudo">ltac</span><span class="operator">.</span><span class="name">collect</span><span class="operator">-</span><span class="name">goals</span></code> API helps us to do this operation.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Tactic split_ll_bis.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Accumulate lp:{{
  <span class="kp">solve</span> (goal Ctx Trigger {{ lp:A /\ lp:B }} <span class="kn">Proof</span> []) GL :- !,
    % this triggers the elaboration
    Trigger = {{ conj _ _ }},                   
    % we <span class="kp">only</span> take main goals
    coq.<span class="kp">ltac</span>.collect-goals <span class="kn">Proof</span> GL _ShelvedGL.
  <span class="kp">solve</span> _ _ :-
    coq.<span class="kp">ltac</span>.<span class="kp">fail</span> _ <span class="s2">&quot;not a conjunction&quot;</span>.
}}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk53"><span class="highlight">Elpi Typecheck.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">B <span class="kr">is</span> linear: name it _B (discard) or B_ (<span class="kp">fresh</span> variable)
[elpi.typecheck,elpi]</span></blockquote><blockquote class="alectryon-message"><span class="highlight">A <span class="kr">is</span> linear: name it _A (discard) or A_ (<span class="kp">fresh</span> variable)
[elpi.typecheck,elpi]</span></blockquote><blockquote class="alectryon-message"><span class="highlight">Ctx <span class="kr">is</span> linear: name it _Ctx (discard) or Ctx_ (<span class="kp">fresh</span> variable)
[elpi.typecheck,elpi]</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk54"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_split_ll_bis</span> : <span class="kr">exists</span> <span class="nv">t</span> : <span class="kt">Prop</span>, <span class="kt">True</span> /\ <span class="kt">True</span> /\ t.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">t</span> : <span class="kt">Prop</span>, <span class="kt">True</span> /\ <span class="kt">True</span> /\ t</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk55"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">t</span> : <span class="kt">Prop</span>, <span class="kt">True</span> /\ <span class="kt">True</span> /\ t</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk56"><span class="highlight"><span class="nb">eexists</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span> /\ <span class="kt">True</span> /\ <span class="nl">?t</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk57"><span class="highlight"><span class="kp">repeat</span> elpi split_ll_bis.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk58" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">True</span></span></div></blockquote><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk59" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="nl">?t</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kp">all</span>: elpi blind.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>At the light of that, refine is simply:</p>
<pre class="code literal-block">
refine T (goal _ RawEv _ Ev _) GS :-
  RawEv = T, coq.ltac.collect-goals Ev GS _.
</pre>
<p>Now that we know the low level plumbing, we can use <code class="highlight coq"><span class="name builtin">refine</span></code>. The only detail
we still have to explain is what exactly a <code class="highlight coq"><span class="name">sealed</span><span class="operator">-</span><span class="name">goal</span></code> is. A sealed goal
wraps into a single object all the proof variable and the assumptions about
them, making this object easy (or better, sound) to pass around. More details
in the next section.</p>
</div>
<div class="section" id="msolve-and-tactic-composition">
<h1><a class="toc-backref" href="#id7">msolve and tactic composition</a></h1>
<p>Since Coq 8.4 tactics can see more than one goal (multi-goal tactics).
You can access this feature by using <code class="highlight coq"><span class="keyword pseudo">all</span><span class="operator">:</span> <span class="name">tactic</span></code>:</p>
<ul class="simple">
<li>if the tactic is a regular one, it will be used on each goal independently</li>
<li>if the tactic is a multi-goal one, it will receive all goals</li>
</ul>
<p>In Elpi you can implement a multi-goal tactic by providing a clause for
the <code class="highlight coq"><span class="name">msolve</span></code> predicate. Since such tactic will need to manipulate multiple
goals, potentially living in different proof context, it receives a list
of sealed-goal, a data type which seals a goal and its proof context.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Tactic ngoals.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Accumulate lp:{{

  msolve GL _ :-
    coq.say <span class="s2">&quot;#goals =&quot;</span> {std.length GL},
    coq.say GL.

}}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Typecheck.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk5a"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_undup</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) : P /\ Q.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P /\ Q</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk5b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P /\ Q</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk5c"><span class="highlight"><span class="nb">split</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk5d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="tutorial-coq-elpi-tactic-v-chk5d"><hr></label><div class="goal-conclusion"><span class="highlight">Q</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk5e"><span class="highlight"><span class="kp">all</span>: elpi ngoals.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">#goals = <span class="mi">2</span></span></blockquote><blockquote class="alectryon-message"><span class="highlight">[(nabla c0 \
   nabla c1 \
    seal
     (goal [decl c1 `Q` (sort prop), decl c0 `P` (sort prop)] (X0 c0 c1) c0 
       (X1 c0 c1) [])), 
 (nabla c0 \
   nabla c1 \
    seal
     (goal [decl c1 `Q` (sort prop), decl c0 `P` (sort prop)] (X2 c0 c1) c1 
       (X3 c0 c1) []))]</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk5f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="tutorial-coq-elpi-tactic-v-chk5f"><hr></label><div class="goal-conclusion"><span class="highlight">Q</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Abort</span>.</span></span></span></pre><p>This simple tactic prints the number of goals it receives, as well as
the list itself. We see something like:</p>
<pre class="code literal-block">
#goals = 2
[(nabla c0 \
   nabla c1 \
	   seal
     (goal [decl c1 `Q` (sort prop), decl c0 `P` (sort prop)] (X0 c0 c1) c0 
       (X1 c0 c1) [])), 
 (nabla c0 \
   nabla c1 \
    seal
     (goal [decl c1 `Q` (sort prop), decl c0 `P` (sort prop)] (X2 c0 c1) c1 
       (X3 c0 c1) []))]
</pre>
<p><code class="highlight coq"><span class="name">nabla</span></code> binds all proof variables, then <code class="highlight coq"><span class="name">seal</span></code> holds a regular goal, which in
turn carries the context (the type of the proof variables).</p>
<p>In order to operate inside a goal one can use the <code class="highlight coq"><span class="name">coq</span><span class="operator">.</span><span class="keyword pseudo">ltac</span><span class="operator">.</span><span class="name">open</span></code> utility,
which postulates all proof variables using pi and loads the goal context
using <code class="highlight coq"><span class="operator">=&gt;</span></code>.</p>
<p>Operating on multiple goals is doable, but not easy. In particular the
two proof context have to be related in some way.</p>
<p>The following simple
multi goal tactic shrinks the list of goals by removing duplicates.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Tactic undup.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Accumulate lp:{{

  pred same-goal i:sealed-goal, i:sealed-goal.
  same-goal (nabla G1) (nabla G2) :-
    pi x\ same-goal (G1 x) (G2 x).
  same-goal (seal (goal Ctx1 _ Ty1 P1 _) <span class="kr">as</span> G1)
            (seal (goal Ctx2 _ Ty2 P2 _) <span class="kr">as</span> G2) :-
    same-ctx Ctx1 Ctx2,
    % this <span class="kr">is</span> an elpi builtin, does not <span class="nb">unify</span>, just <span class="nb">compare</span>
    Ty1 == Ty2,
    P1 = P2.

  pred same-ctx i:goal-ctx, i:goal-ctx.
  same-ctx [] [].
  same-ctx [decl V _ T1|C1] [decl V _ T2|C2] :-
    % TODO: we could <span class="nb">compare</span> up to permutation...
    T1 == T2,
    same-ctx C1 C2.

  pred undup i:sealed-goal, i:list sealed-goal, o:list sealed-goal.
  undup _ [] [].
  undup G [G1|GN] GN :- same-goal G G1.
  undup G [G1|GN] [G1|GL] :- undup G GN GL.

  msolve [G1|GS] [G1|GL] :-
    % TODO: we could find <span class="kp">all</span> duplicates, not just
    % copies of the <span class="kp">first</span> one...
    undup G1 GS GL.

}}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk60"><span class="highlight">Elpi Typecheck.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">G2 <span class="kr">is</span> linear: name it _G2 (discard) or G2_ (<span class="kp">fresh</span> variable)
[elpi.typecheck,elpi]</span></blockquote><blockquote class="alectryon-message"><span class="highlight">G1 <span class="kr">is</span> linear: name it _G1 (discard) or G1_ (<span class="kp">fresh</span> variable)
[elpi.typecheck,elpi]</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk61"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_undup</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">p</span> : P) (<span class="nv">q</span> : Q) : P /\ Q /\ P.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Q</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P /\ Q /\ P</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk62"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Q</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P /\ Q /\ P</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk63"><span class="highlight"><span class="kp">repeat</span> <span class="nb">split</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Q</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk64" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Q</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="tutorial-coq-elpi-tactic-v-chk64"><hr></label><div class="goal-conclusion"><span class="highlight">Q</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk65" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Q</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="tutorial-coq-elpi-tactic-v-chk65"><hr></label><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk66"><span class="highlight"><span class="kn">Show Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">(<span class="kr">fun</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">p</span> : P) (<span class="nv">q</span> : Q) =&gt;
 conj <span class="nl">?Goal</span> (conj <span class="nl">?Goal0</span> <span class="nl">?Goal1</span>))</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Q</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk67" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Q</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="tutorial-coq-elpi-tactic-v-chk67"><hr></label><div class="goal-conclusion"><span class="highlight">Q</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk68" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Q</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="tutorial-coq-elpi-tactic-v-chk68"><hr></label><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk69"><span class="highlight"><span class="kp">all</span>: elpi undup.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Q</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk6a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Q</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="tutorial-coq-elpi-tactic-v-chk6a"><hr></label><div class="goal-conclusion"><span class="highlight">Q</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk6b"><span class="highlight"><span class="kn">Show Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">(<span class="kr">fun</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Prop</span>) (<span class="nv">p</span> : P) (<span class="nv">q</span> : Q) =&gt;
 conj <span class="nl">?Goal0</span> (conj <span class="nl">?Goal</span> <span class="nl">?Goal0</span>))</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Q</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-coq-elpi-tactic-v-chk6c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Q</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="tutorial-coq-elpi-tactic-v-chk6c"><hr></label><div class="goal-conclusion"><span class="highlight">Q</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk6d"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Q</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> p.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk6e"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P, Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Q</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Q</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> q.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>The two calls to show proof display, respectively:</p>
<pre class="code coq literal-block">
<span class="operator">(</span><span class="keyword reserved">fun</span> <span class="operator">(</span><span class="name variable">P</span> <span class="name variable">Q</span> <span class="operator">:</span> <span class="keyword type">Prop</span><span class="operator">)</span> <span class="operator">(</span><span class="name variable">p</span> <span class="operator">:</span> <span class="name">P</span><span class="operator">)</span> <span class="operator">(</span><span class="name variable">q</span> <span class="operator">:</span> <span class="name">Q</span><span class="operator">)</span> <span class="operator">=&gt;</span> <span class="name">conj</span> <span class="name label">?Goal</span> <span class="operator">(</span><span class="name">conj</span> <span class="name label">?Goal0</span> <span class="name label">?Goal1</span><span class="operator">))</span>
<span class="operator">(</span><span class="keyword reserved">fun</span> <span class="operator">(</span><span class="name variable">P</span> <span class="name variable">Q</span> <span class="operator">:</span> <span class="keyword type">Prop</span><span class="operator">)</span> <span class="operator">(</span><span class="name variable">p</span> <span class="operator">:</span> <span class="name">P</span><span class="operator">)</span> <span class="operator">(</span><span class="name variable">q</span> <span class="operator">:</span> <span class="name">Q</span><span class="operator">)</span> <span class="operator">=&gt;</span> <span class="name">conj</span> <span class="name label">?Goal0</span> <span class="operator">(</span><span class="name">conj</span> <span class="name label">?Goal</span> <span class="name label">?Goal0</span><span class="operator">))</span>
</pre>
<p>the proof term is the same but for the fact that after the tactic the first
and last missing subterm (incomplete proof tree branch) are represented by
the same hole. Indeed by solving one, we can also solve the other.</p>
<p>On the notion of sealed-goal it is easy to define the usual LCF combinators,
also known as Ltac tacticals. A few ones can be find in the
<a class="reference external" href="https://github.com/LPCIC/coq-elpi/blob/master/elpi/elpi-ltac.elpi">elpi-ltac.elpi file</a>.</p>
<p>As we hinted before, tactic arguments are attached to the goal, since
they can mention proof variables. So the Ltac code</p>
<pre class="code coq literal-block">
<span class="name builtin">intro</span> <span class="name">H</span><span class="operator">;</span> <span class="name builtin">apply</span> <span class="name">H</span><span class="operator">.</span>
</pre>
<p>has to be seen as 3 steps, starting from a goal G:</p>
<ul class="simple">
<li>introduction of <code class="highlight coq"><span class="name">H</span></code>, obtaining G1</li>
<li>setting the argument <code class="highlight coq"><span class="name">H</span></code>, obtaining G2</li>
<li>calling apply, obtaining G3</li>
</ul>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Tactic argpass.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Accumulate lp:{{

 shorten coq.<span class="kp">ltac</span>.{ open, thenl, <span class="kp">all</span> }.

  type <span class="nb">intro</span> open-tactic. % goal -&gt; list sealed-goal
  <span class="nb">intro</span> G GL :- <span class="nb">refine</span> {{ <span class="kr">fun</span> <span class="nv">H</span> =&gt; _ }} G GL.

  type <span class="nb">set</span>-arg-n-hyp int -&gt; open-tactic.
  <span class="nb">set</span>-arg-n-hyp N (goal Ctx _ _ _ _ <span class="kr">as</span> G) [SG1] :-
    std.nth N Ctx (decl X _ _),
    coq.<span class="kp">ltac</span>.<span class="nb">set</span>-goal-arguments [trm X] G (seal G) SG1.

  type <span class="nb">apply</span> open-tactic.
  <span class="nb">apply</span> (goal _ _ _ _ [trm T] <span class="kr">as</span> G) GL :- <span class="nb">refine</span> T G GL.

  msolve SG GL :-
    <span class="kp">all</span> (thenl [ open <span class="nb">intro</span>,
                 open (<span class="nb">set</span>-arg-n-hyp <span class="mi">0</span>),
                open <span class="nb">apply</span> ]) SG GL.

}}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Typecheck.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk6f"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">test_argpass</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) : P -&gt; P.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P -&gt; P</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk70"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P -&gt; P</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">elpi argpass.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>Of course the tactic playing the role of <code class="highlight coq"><span class="name builtin">intro</span></code> could communicate back
a datum to be passed to what follows</p>
<pre class="code literal-block">
thenl [ open (tac1 Datum), open (tac2 Datum) ]
</pre>
<p>but the binder structure of <code class="highlight coq"><span class="name">sealed</span><span class="operator">-</span><span class="name">goal</span></code> would prevent <code class="highlight coq"><span class="name">Datum</span></code> to mention
proof variables, that would otherwise escape the sealing. The utility</p>
<pre class="code literal-block">
coq.ltac.set-goal-arguments Args G G1 G1wArgs
</pre>
<p>tries to move <code class="highlight coq"><span class="name">Args</span></code> from the context of G to the one of G1. Relating the
two proof contexts is not obvious: you may need to write your own procedure
if the two contexts are very distant.</p>
</div>
<div class="section" id="tactic-in-terms">
<h1><a class="toc-backref" href="#id8">Tactic in terms</a></h1>
<p>Elpi tactics can be used inside terms via the usual <code class="highlight coq"><span class="keyword pseudo">ltac</span><span class="operator">:(...)</span></code>
quotation, but can also be exported in the term grammar.</p>
<p>Here we write a simple tactic for default values, which
optionally takes a bound to the search depth.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Tactic default.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Accumulate lp:{{

  pred default i:term, i:int, o:term.
  default _ <span class="mi">0</span> _ :- coq.error <span class="s2">&quot;max search depth reached&quot;</span>.
  default {{nat}} _ {{<span class="mi">46</span>}}.
  default {{bool}} _ {{false}}.
  default {{list lp:A}} Max {{cons lp:D nil}} :-
    Max&#39; <span class="kr">is</span> Max - <span class="mi">1</span>, default A Max&#39; D.

  <span class="kp">solve</span> (goal _ _ T _ [] <span class="kr">as</span> G) GL :-
    default T <span class="mi">9999</span> P,
    <span class="nb">refine</span> P G GL.

}}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Typecheck.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi <span class="kn">Export</span> default.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">foo</span> : nat := default.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">bar</span> : list bool := default.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk71"><span class="highlight"><span class="kn">Print</span> foo.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">foo = <span class="mi">46</span>
     : nat</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk72"><span class="highlight"><span class="kn">Print</span> bar.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">bar = (false :: nil)%list
     : list bool</span></blockquote></div></div></small></span></pre><p>The grammar entries for Elpi tactics in terms take an arbitrary
number of arguments with the limitation that they are all terms:
you can't pass a string or an integer as would normally do.</p>
<p>Here we use Coq's primitive integers to pass the search depth
(in a compact way).</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Accumulate default lp:{{
  <span class="kp">solve</span> (goal _ _ T _ [trm (primitive (uint63 Max))] <span class="kr">as</span> G) GL :-
    coq.uint63-&gt;int Max MaxI,    
    default T MaxI P,
    <span class="nb">refine</span> P G GL.
}}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">Elpi Typecheck.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">From</span> Coq <span class="kn">Require Import</span>  Int63.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Open Scope</span> int63_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk73"><span class="highlight"><span class="kn">Fail</span> <span class="kn">Definition</span> <span class="nf">baz</span> : list nat := default <span class="mi">1</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">The command has indeed failed <span class="kr">with</span> message:
max search depth reached</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">baz</span> : list nat := default <span class="mi">2</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-tactic-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-tactic-v-chk74"><span class="highlight"><span class="kn">Print</span> baz.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">baz = (<span class="mi">46</span>%nat :: nil)%list
     : list nat</span></blockquote></div></div></small></span></pre><p>That is all folks!</p>
<script>
var style = document.createElement('style');
style.textContent = `
  .alectryon-io {
     border-left-style: solid;
     border-left-color: lightgrey;
     padding-left: 1em;
     margin-left: 1em;
  }
  code.coq {
     border-style: solid;
     border-color: lightgrey;
     border-width: 0.1em;
     padding: 0.2em 0.3em 0.2em 0.3em;
     border-radius: 0.5em
  }
  body {
    line-height: 2;
  }
  div.warning , div.important, div.warning, div.note {
     border-style: solid;
     border-color: lightgrey;
     border-width: 0.1em;
     border-radius: 0.5em
  }
`;
document.getElementsByTagName('head')[0].appendChild(style);
</script></div>
</div>
</div>
</div></body>
</html>
